<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>可验证计算与零知识证明：构建信任、隐私与可扩展的未来 | qmwneb946 的博客</title><meta name="author" content="qmwneb946"><meta name="copyright" content="qmwneb946"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="你好，技术探索者们！我是 qmwneb946，你们的博主。今天，我们将一同深入一个在数字世界中正掀起革命的领域：可验证计算（Verifiable Computation, VC）与零知识证明（Zero-Knowledge Proofs, ZKP）。这不仅仅是理论上的突破，更是我们如何构建更信任、更私密、更高效的数字基础设施的核心基石。 想象一下这样的场景：你将敏感的计算任务外包给云服务提供商，或者">
<meta property="og:type" content="article">
<meta property="og:title" content="可验证计算与零知识证明：构建信任、隐私与可扩展的未来">
<meta property="og:url" content="https://qmwneb946.dpdns.org/2025/07/22/2025-07-22-170440/index.html">
<meta property="og:site_name" content="qmwneb946 的博客">
<meta property="og:description" content="你好，技术探索者们！我是 qmwneb946，你们的博主。今天，我们将一同深入一个在数字世界中正掀起革命的领域：可验证计算（Verifiable Computation, VC）与零知识证明（Zero-Knowledge Proofs, ZKP）。这不仅仅是理论上的突破，更是我们如何构建更信任、更私密、更高效的数字基础设施的核心基石。 想象一下这样的场景：你将敏感的计算任务外包给云服务提供商，或者">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qmwneb946.dpdns.org/img/icon.png">
<meta property="article:published_time" content="2025-07-22T09:04:40.000Z">
<meta property="article:modified_time" content="2025-07-23T10:05:21.078Z">
<meta property="article:author" content="qmwneb946">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="可验证计算与零知识证明">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qmwneb946.dpdns.org/img/icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "可验证计算与零知识证明：构建信任、隐私与可扩展的未来",
  "url": "https://qmwneb946.dpdns.org/2025/07/22/2025-07-22-170440/",
  "image": "https://qmwneb946.dpdns.org/img/icon.png",
  "datePublished": "2025-07-22T09:04:40.000Z",
  "dateModified": "2025-07-23T10:05:21.078Z",
  "author": [
    {
      "@type": "Person",
      "name": "qmwneb946",
      "url": "https://github.com/qmwneb946"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qmwneb946.dpdns.org/2025/07/22/2025-07-22-170440/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '可验证计算与零知识证明：构建信任、隐私与可扩展的未来',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2845632165165414" crossorigin="anonymous"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="qmwneb946 的博客" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">qmwneb946 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">可验证计算与零知识证明：构建信任、隐私与可扩展的未来</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">可验证计算与零知识证明：构建信任、隐私与可扩展的未来<a class="post-edit-link" href="https://github.com/qmwneb946/blog/edit/main/source/_posts/2025-07-22-170440.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-22T09:04:40.000Z" title="发表于 2025-07-22 17:04:40">2025-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-23T10:05:21.078Z" title="更新于 2025-07-23 18:05:21">2025-07-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>你好，技术探索者们！我是 qmwneb946，你们的博主。今天，我们将一同深入一个在数字世界中正掀起革命的领域：可验证计算（Verifiable Computation, VC）与零知识证明（Zero-Knowledge Proofs, ZKP）。这不仅仅是理论上的突破，更是我们如何构建更信任、更私密、更高效的数字基础设施的核心基石。</p>
<p>想象一下这样的场景：你将敏感的计算任务外包给云服务提供商，或者参与一个区块链网络，其上的交易需要所有节点验证，或者你想向某人证明你满足了某个条件（比如年龄），却不想泄露任何个人信息。在这些场景中，我们面临着核心挑战：如何确保计算的正确性，如何在不牺牲隐私的前提下进行验证，以及如何让这些验证过程变得足够高效以支持大规模应用？</p>
<p>传统方法往往依赖于中心化的信任方，或者要求所有参与者进行冗余的完整计算。前者带来单点故障和信任危机，后者则导致巨大的资源浪费和可扩展性瓶颈。零知识证明和可验证计算正是为了解决这些根本性问题而生。它们承诺了一种范式转变：我们不再需要盲目信任，也不再需要重复计算一切。取而代之的是，一个“证明者”（Prover）可以向一个“验证者”（Verifier）提供一个简短的“密码学证明”，以证实某个复杂计算的正确性或某个秘密信息的真实性，而验证者只需花费极少的资源即可核实，并且在验证过程中，验证者不会学到任何额外的秘密信息。</p>
<p>这听起来像是科幻小说，但它已经成为现实，并正在区块链、云计算、人工智能和隐私保护等多个领域开花结果。本文将带你从理论到实践，逐步揭开可验证计算与零知识证明的神秘面纱，探索它们的工作原理、核心技术、以及它们将如何重塑我们的数字未来。</p>
<p>准备好了吗？让我们开始这段硬核的探索之旅！</p>
<h2 id="第一章：信任、可扩展性与隐私的困境">第一章：信任、可扩展性与隐私的困境</h2>
<p>在深入了解可验证计算和零知识证明之前，我们必须先理解它们试图解决的核心问题。现代计算的基石——信任、可扩展性和隐私——正面临前所未有的挑战。</p>
<h3 id="信任危机：我们能相信谁？">信任危机：我们能相信谁？</h3>
<p>在数字世界中，信任无处不在，却又如此脆弱。</p>
<ul>
<li><strong>云计算的黑箱问题：</strong> 当我们将数据和计算任务外包给亚马逊AWS、微软Azure或谷歌云等大型云服务提供商时，我们本质上是在信任它们能正确、安全地执行我们的代码，并返回正确的结果。但我们如何能确保它们没有出错、没有恶意篡改，甚至没有利用我们的数据？我们无法直接观察它们的服务器内部。</li>
<li><strong>区块链的共识挑战：</strong> 在像比特币或以太坊这样的去中心化网络中，每个节点都需要独立验证每一笔交易和每一个区块的有效性，以确保整个账本的一致性和正确性。这种“人人验证”的模式固然增强了去中心化和抗审查性，但随着交易量的增长，它也带来了巨大的可扩展性问题。每个节点都必须存储完整的历史数据并执行所有计算，这使得加入网络或运行一个全节点变得资源密集且效率低下。</li>
<li><strong>外包计算的风险：</strong> 在许多科学研究、金融建模或大数据分析场景中，个人或小型机构可能会将复杂的计算任务外包给拥有强大算力的第三方。在这种情况下，如何确保第三方返回的结果是准确无误的，而非谎言或错误？</li>
</ul>
<p>传统解决方案通常依赖于审计、冗余计算或法律合约，但这些方法成本高昂、效率低下，且无法从根本上解决信任缺失的问题。</p>
<h3 id="可扩展性瓶颈：性能的枷锁">可扩展性瓶颈：性能的枷锁</h3>
<p>随着数字服务的普及和数据量的爆炸式增长，可扩展性成为了一个日益严峻的挑战。</p>
<ul>
<li><strong>区块链的“不可能三角”：</strong> 区块链技术经常被提及的“不可能三角”——去中心化、安全性和可扩展性——意味着我们很难同时实现这三者。为了保持去中心化和安全性，许多区块链牺牲了可扩展性，导致交易吞吐量低下，费用高昂。例如，以太坊主网目前的交易处理能力远不能满足全球对去中心化应用（dApps）的需求。</li>
<li><strong>分布式系统的协调开销：</strong> 在大型分布式系统中，为了确保数据一致性和计算正确性，往往需要复杂的协调机制，如共识协议。这些机制在确保可靠性的同时，也带来了显著的通信开销和延迟，限制了系统的整体吞吐量。</li>
<li><strong>计算资源的浪费：</strong> 在“人人验证”的模式下，大量的计算资源被用于重复执行相同的验证逻辑。例如，如果一个计算任务需要100个节点来验证，那么这个任务实际上被执行了100次。这种冗余是去中心化网络的代价，但也是其主要瓶颈之一。</li>
</ul>
<h3 id="隐私泄露：数据的裸奔">隐私泄露：数据的裸奔</h3>
<p>在数据驱动的时代，隐私已成为个人和企业最宝贵的资产之一。</p>
<ul>
<li><strong>身份验证的困境：</strong> 当我们需要向他人证明我们的身份、年龄、学历或财务状况时，往往不得不泄露过多的个人信息。例如，购买酒精时，你需要展示身份证，这不仅证明了你的年龄，还暴露了你的姓名、住址、出生日期等所有信息。</li>
<li><strong>数据共享的矛盾：</strong> 在医疗、金融或社会科学研究中，数据共享对于推进知识和创新至关重要。然而，这些数据往往包含高度敏感的个人信息。如何在利用数据价值的同时，保护数据主体的隐私，是一个巨大的挑战。</li>
<li><strong>机器学习的隐私问题：</strong> 在训练或部署机器学习模型时，输入数据可能包含敏感信息，模型本身也可能包含有价值的知识产权。如何在不泄露这些秘密的前提下，证明模型的准确性或预测结果？</li>
</ul>
<p>传统的加密技术（如数据加密）可以在传输和存储过程中保护数据，但当数据需要被计算或验证时，通常需要解密，从而暴露其内容。这使得在计算过程中保持隐私变得异常困难。</p>
<h3 id="可验证计算与零知识证明：希望之光">可验证计算与零知识证明：希望之光</h3>
<p>正是为了解决这些深层次的信任、可扩展性与隐私问题，可验证计算和零知识证明应运而生。</p>
<ul>
<li><strong>可验证计算（VC）</strong> 旨在解决信任和可扩展性问题：一个计算任务的执行者（证明者）可以快速生成一个简短的证明，证明其计算结果的正确性。而验证者可以仅凭这个证明，以远低于重新执行计算的成本，快速验证结果的正确性。这实现了计算的“外包-验证”模式，极大地提升了效率和信任度。</li>
<li><strong>零知识证明（ZKP）</strong> 旨在解决隐私问题：它允许一个证明者向验证者证明某个陈述是真实的，而无需透露任何关于该陈述的额外信息。这意味着你可以证明你知道一个秘密，而无需泄露这个秘密本身。当ZKP与VC结合时，我们便得到了“零知识可验证计算”，即在不泄露输入或中间计算结果的情况下，证明计算的正确性。</li>
</ul>
<p>在接下来的章节中，我们将详细探索这些概念，揭示它们如何共同构建一个更安全、更高效、更尊重隐私的数字未来。</p>
<h2 id="第二章：可验证计算：审计未来的计算">第二章：可验证计算：审计未来的计算</h2>
<p>可验证计算（Verifiable Computation, VC）是构建去中心化、可信赖计算系统的基石。它的核心思想是：一个实体（证明者）执行一个复杂的计算，并生成一个简洁的证明，另一个实体（验证者）只需很少的努力就能高效地验证这个计算结果的正确性。</p>
<h3 id="什么是可验证计算？">什么是可验证计算？</h3>
<p>可验证计算，顾名思义，是关于如何“验证”一个“计算”的过程。具体来说，它是一个密码学协议，涉及两个主要角色：</p>
<ol>
<li><strong>证明者 (Prover, P)</strong>：负责执行一个给定的计算任务 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">C(x) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 是输入， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是输出。除了计算结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 之外，证明者还会生成一个简洁的、密码学安全的<strong>证明 (Proof, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>)</strong>。</li>
<li><strong>验证者 (Verifier, V)</strong>：接收计算的输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>、声称的输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 以及证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>。验证者的任务是利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> 在不重新执行整个计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 的情况下，快速地判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是否确实是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 的正确结果。</li>
</ol>
<p>理想的可验证计算系统应具备以下关键特性：</p>
<ul>
<li><strong>完备性 (Completeness)</strong>：如果计算是正确执行的（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = C(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> ），那么诚实的证明者总能生成一个证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>，使得诚实的验证者能够成功验证。</li>
<li><strong>可靠性/健全性 (Soundness)</strong>：如果计算是错误执行的（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo mathvariant="normal">≠</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \neq C(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> ），那么恶意证明者几乎不可能生成一个能通过验证的证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>。</li>
<li><strong>简洁性 (Succinctness)</strong>：证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span> 的大小应远小于原始计算的痕迹（例如，计算轨迹的长度或输入数据的规模），且验证时间应远小于重新执行整个计算的时间。通常，我们追求证明大小为常数或对数级别，验证时间为对数或常数级别。</li>
<li><strong>效率 (Efficiency)</strong>：证明生成时间应该尽可能接近原始计算时间（理想情况下是线性或准线性）。</li>
</ul>
<h3 id="为什么我们需要可验证计算？">为什么我们需要可验证计算？</h3>
<p>可验证计算的实用价值体现在解决我们在第一章中讨论的信任和可扩展性问题。</p>
<ul>
<li><strong>云计算场景：</strong> 公司可以将复杂的财务分析、基因序列匹配或大数据处理任务外包给云服务。云服务提供商作为证明者执行计算并返回结果及证明。公司作为验证者，可以快速核实结果，而无需担心云服务商的错误或欺诈。</li>
<li><strong>区块链扩容：</strong> 这是当前可验证计算最热门的应用领域。在以太坊等区块链中，所有节点都必须验证每一笔交易。如果能够通过可验证计算将大量交易“打包”成一个批次，并为这个批次的执行生成一个简洁的证明（例如，证明“从状态A经过这些交易转换到了状态B”），那么链上验证者只需要验证这个单一的证明，而无需处理所有单独的交易。这极大地减少了链上计算负荷，从而提升了区块链的交易吞吐量，这正是 Rollup 技术（特别是 zk-Rollup）的核心原理。</li>
<li><strong>去中心化自治组织（DAO）中的投票：</strong> DAO可以利用VC来验证复杂的投票结果或财务计算，而无需所有成员独立执行这些计算。</li>
<li><strong>安全多方计算（MPC）的补充：</strong> MPC允许多方在不透露各自输入的情况下协同计算一个函数。VC可以用来在MPC完成后，由一个聚合证明者来证明最终结果的正确性，避免了所有参与者都存储并核对所有中间结果。</li>
</ul>
<h3 id="可验证计算的类型">可验证计算的类型</h3>
<p>可验证计算方案可以根据其交互性、透明性以及底层密码学假设进行分类。</p>
<h4 id="1-交互式证明系统-Interactive-Proof-Systems-IPS">1. 交互式证明系统 (Interactive Proof Systems, IPS)</h4>
<ul>
<li><strong>概念：</strong> 证明者和验证者之间通过一系列消息进行多次交互，最终验证者决定是否接受证明者的声明。</li>
<li><strong>例子：</strong> 著名的图同构问题（Graph Isomorphism）的交互式零知识证明。一个证明者想要证明两个图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是同构的，但不愿透露同构映射本身。验证者可以通过多次挑战来确认证明者确实知道这个映射。</li>
<li><strong>局限性：</strong> 需要多轮交互，无法用于区块链等异步、非交互的环境。</li>
</ul>
<h4 id="2-非交互式证明系统-Non-Interactive-Proof-Systems-NIPS">2. 非交互式证明系统 (Non-Interactive Proof Systems, NIPS)</h4>
<ul>
<li><strong>概念：</strong> 证明者只需生成一个证明，发送给验证者，验证者独立完成验证，无需任何进一步交互。</li>
<li><strong>重要性：</strong> 对于区块链、离线验证等场景至关重要，因为证明可以生成一次并在任何地方被多次验证。</li>
<li><strong>转换方法：</strong> 通常通过<strong>Fiat-Shamir 启发式</strong>将交互式证明转换为非交互式。简单来说，Fiat-Shamir 将验证者的挑战替换为一个公开可验证的哈希函数，哈希函数的输入包含之前所有的通信内容，使得挑战看起来像是“随机”生成的。</li>
<li><strong>主要代表：</strong> zk-SNARKs 和 zk-STARKs 是当前最先进、最受关注的非交互式可验证计算系统。它们通常也具有零知识特性，因此被称为zk-SNARKs/zk-STARKs。</li>
</ul>
<h3 id="可验证计算的核心挑战">可验证计算的核心挑战</h3>
<p>尽管前景光明，可验证计算也面临着挑战：</p>
<ul>
<li><strong>证明生成开销：</strong> 生成一个有效证明所需的计算资源通常远大于原始计算本身。这是证明者效率的瓶颈，也是当前研究的重点之一。</li>
<li><strong>电路表达：</strong> 几乎所有的现代VC方案都需要将原始计算转化为一种特定的数学形式，通常是算术电路或更底层的约束系统（如R1CS、AIR）。这个转换过程本身可能很复杂，且效率高低直接影响证明生成的速度。</li>
<li><strong>密码学假设：</strong> 许多VC方案依赖于复杂的密码学假设（如椭圆曲线上的离散对数问题、配对友好曲线），这些假设的安全性可能会受到量子计算的威胁。</li>
</ul>
<p>下一章我们将深入零知识证明，探索它如何为可验证计算添加“隐私”的魔法。</p>
<h2 id="第三章：零知识证明：隐私保护的艺术">第三章：零知识证明：隐私保护的艺术</h2>
<p>零知识证明（Zero-Knowledge Proofs, ZKP）是密码学领域最迷人、最具变革性的概念之一。它不仅仅是关于“验证计算”，更是关于“在不泄露任何秘密信息的情况下证明一个事实”。</p>
<h3 id="什么是零知识证明？">什么是零知识证明？</h3>
<p>一个零知识证明系统允许一个<strong>证明者 (Prover, P)</strong> 向一个<strong>验证者 (Verifier, V)</strong> 证明一个陈述（Statement）是真实的，而无需向验证者透露任何关于该陈述的额外信息（即，除了“陈述是真的”这个事实之外，验证者学不到任何其他东西）。</p>
<h3 id="ZKP-的“三性”">ZKP 的“三性”</h3>
<p>要成为一个合格的零知识证明，系统必须满足以下三个核心属性：</p>
<ol>
<li>
<p><strong>完备性 (Completeness)</strong>：</p>
<ul>
<li>如果证明者知道真实的秘密（即陈述确实为真），那么诚实的证明者总能成功地生成一个有效的证明，并让诚实的验证者相信这个陈述是真实的。</li>
<li>用数学语言来说，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 是一个真陈述，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Prob</mtext><mo stretchy="false">[</mo><mi>V</mi><mo stretchy="false">(</mo><mtext>Proof</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>W</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mtext>Accept</mtext><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{Prob}[V(\text{Proof}(P(S, W))) = \text{Accept}] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Prob</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord text"><span class="mord">Proof</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">)))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Accept</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的证人（witness，即证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 为真所需的秘密信息）。</li>
</ul>
</li>
<li>
<p><strong>可靠性/健全性 (Soundness)</strong>：</p>
<ul>
<li>如果陈述是假的（即证明者不拥有真实的秘密），那么恶意证明者几乎不可能欺骗诚实的验证者，使其相信这个假的陈述是真的。</li>
<li>用数学语言来说，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 是一个假陈述，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Prob</mtext><mo stretchy="false">[</mo><mi>V</mi><mo stretchy="false">(</mo><mtext>Proof</mtext><mo stretchy="false">(</mo><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><msup><mi>W</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mtext>Accept</mtext><mo stretchy="false">]</mo><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{Prob}[V(\text{Proof}(P&#x27;(S, W&#x27;))) = \text{Accept}] \approx 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Prob</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord text"><span class="mord">Proof</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Accept</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">P&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 是恶意证明者， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">W&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 是一个假证人。这里的“几乎不可能”通常指概率可以小到任意程度（例如，通过重复协议多次）。</li>
</ul>
</li>
<li>
<p><strong>零知识性 (Zero-Knowledge)</strong>：</p>
<ul>
<li>如果陈述是真实的，那么验证者在验证过程中除了得知“陈述是真的”这个事实之外，学不到任何关于证明者所拥有的秘密信息的额外知识。</li>
<li>这是最直观也最难以理解的属性。它通常通过模拟器 (Simulator) 的概念来形式化。如果存在一个模拟器，它在不知道证人 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> 的情况下，仅仅通过与验证者交互（或者在非交互式情况下，仅通过输出一个看起来像真实证明的字符串），就能生成一个与真实证明 indistinguishable 的“伪证明”，那么就称该协议具有零知识性。这意味着验证者从真实的证明中获得的信息，和不与证明者交互自己“编造”出来的信息是一样的，从而没有学到任何秘密。</li>
</ul>
</li>
</ol>
<h3 id="经典的“洞穴比喻”">经典的“洞穴比喻”</h3>
<p>为了帮助理解零知识证明的零知识性，一个著名的比喻是 Ali Baba 洞穴的例子：</p>
<p>想象一个圆形洞穴，入口在A点，尽头是B点和C点，它们之间有一扇魔法门。只有说出咒语才能打开这扇门。</p>
<ul>
<li><strong>证明者 P (Ali Baba)</strong>：声称他知道打开魔法门的咒语。</li>
<li><strong>验证者 V (村民)</strong>：想要验证 P 是否真的知道咒语，但又不想学到咒语本身。</li>
</ul>
<p>协议流程：</p>
<ol>
<li>P 和 V 进入洞穴，V 等待在入口 A。</li>
<li>P 沿着 B 或 C 岔路走到门前。</li>
<li>V 走到入口 A，并随机大喊一声“走到 B”或“走到 C”。</li>
<li>P 收到指令后，如果他走的是另一条路，就需要打开魔法门并走出来。如果他已经在目标路径上，则直接走出来。</li>
<li>P 从 V 指定的出口出现。</li>
</ol>
<p>如果 P 不知道咒语，他只能蒙对一半的概率（1/2），因为他不知道 V 会喊 B 还是 C。如果他反复成功（例如重复100次），那么 V 会非常有信心 P 确实知道咒语，因为 P 连续蒙对 100 次的概率是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mn>100</mn></msup></mrow><annotation encoding="application/x-tex">(1/2)^{100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1/2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100</span></span></span></span></span></span></span></span></span></span></span></span>，这是一个极小的数字。</p>
<p>然而，在这个过程中，V 永远不会知道咒语是什么。P 只是证明了他能打开门，但咒语本身从未被泄露。这就是零知识性。</p>
<h3 id="零知识证明的类型">零知识证明的类型</h3>
<h4 id="1-交互式零知识证明-Interactive-ZKP">1. 交互式零知识证明 (Interactive ZKP)</h4>
<p>如上面的洞穴比喻，需要证明者和验证者进行多轮来回通信。</p>
<ul>
<li><strong>例子：</strong> Graph Isomorphism (图同构) 问题。P 想要证明两个图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是同构的，但他不想透露同构映射。
<ol>
<li>P 生成一个随机同构图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> (即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的同构)，并将其承诺（commit）给 V。</li>
<li>V 随机挑战 P，要求 P 揭示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">G_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的同构还是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">G_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的同构。</li>
<li>P 揭示对应的同构映射。</li>
<li>V 检查映射是否正确。<br>
重复多次，直到 V 确信 P 知道同构映射。</li>
</ol>
</li>
</ul>
<h4 id="2-非交互式零知识证明-Non-Interactive-ZKP-NIZKP">2. 非交互式零知识证明 (Non-Interactive ZKP, NIZKP)</h4>
<p>这是当前应用的主流，特别是区块链领域。证明者生成一个证明后，可以发送给任何验证者进行验证，无需进一步交互。</p>
<ul>
<li><strong>如何实现？</strong> 最常用的方法是 <strong>Fiat-Shamir 启发式 (Fiat-Shamir Heuristic)</strong>。
<ul>
<li>Fiat-Shamir 的核心思想是，将验证者的“随机挑战”替换为一个公开可验证的哈希函数。哈希函数的输入包含所有之前交互的信息以及证明者承诺的某些数据。</li>
<li>由于哈希函数是确定性的，且其输出看起来足够随机，因此可以模拟验证者的随机选择。这样，证明者可以在本地生成所有“挑战”并响应，然后将最终的证明（包括所有承诺、响应和哈希值）打包发送给验证者。验证者只需独立运行哈希函数并检查所有步骤即可。</li>
<li>尽管 Fiat-Shamir 启发式在实践中非常有效且广泛使用，但它在理论上不是一个严格的转换，因为它依赖于“随机预言模型 (Random Oracle Model)”假设，即哈希函数行为像一个完美的随机函数。</li>
</ul>
</li>
</ul>
<h3 id="零知识证明的应用场景">零知识证明的应用场景</h3>
<p>零知识证明的应用潜力是巨大的：</p>
<ul>
<li><strong>隐私保护的区块链交易：</strong> Zcash 等加密货币使用 ZKP 来隐藏交易的发送方、接收方和金额，同时仍能确保交易的有效性（例如，没有超发）。</li>
<li><strong>身份验证：</strong> 证明你年龄超过18岁，而无需透露你的确切生日。证明你是某大学的毕业生，而无需透露你的姓名或学号。</li>
<li><strong>机密投票：</strong> 证明你投票了，但其他人不知道你投了谁。</li>
<li><strong>链上隐私：</strong> 在以太坊上实现更复杂的隐私功能，例如私密 DeFi 交易、匿名社交网络等。</li>
<li><strong>法规遵从（Compliance）：</strong> 公司可以向监管机构证明他们满足了某些合规要求（例如，储备金充足），而无需泄露其详细的财务数据。</li>
<li><strong>零知识机器学习 (ZKML)：</strong> 证明一个机器学习模型在特定输入上产生了某个预测结果，而无需揭示模型的权重或输入数据。这对于保护模型知识产权和用户数据隐私至关重要。</li>
</ul>
<p>下一章，我们将聚焦于零知识证明和可验证计算领域最具影响力的两个家族：zk-SNARKs 和 zk-STARKs，它们是实现这些愿景的核心技术。</p>
<h2 id="第四章：从理论到实践：zk-SNARKs-与-zk-STARKs-的时代">第四章：从理论到实践：zk-SNARKs 与 zk-STARKs 的时代</h2>
<p>在可验证计算和零知识证明的领域，zk-SNARKs 和 zk-STARKs 是当前最前沿、最具影响力的技术。它们是实现简洁、高效、隐私保护的非交互式证明的关键。要理解它们，我们需要先了解如何将任意计算“编码”成它们能处理的数学形式。</p>
<h3 id="计算的算术化：将逻辑转化为代数">计算的算术化：将逻辑转化为代数</h3>
<p>无论是比特币交易、智能合约执行、图片处理算法，还是复杂的机器学习模型，所有的计算本质上都可以被分解为一系列基本的算术运算（加法、乘法）和布尔逻辑运算。零知识证明系统通常要求将这些复杂计算表达成一种特定的“代数约束系统”，例如：</p>
<ul>
<li>
<p><strong>算术电路 (Arithmetic Circuits)</strong>：计算被表示为一个由加法门 (+) 和乘法门 (*) 组成的电路。输入值通过这些门进行传递，最终产生输出。</p>
</li>
<li>
<p><strong>Rank-1 Constraint System (R1CS)</strong>：这是 zk-SNARKs 中最常用的编码方式。一个 R1CS 系统由一系列形如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo>⋅</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mi>i</mi></msub><mo>⋅</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo>⋅</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_i \cdot x) \cdot (b_i \cdot x) = (c_i \cdot x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 的约束组成，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 是一个包含了所有输入、输出和中间值的向量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i, b_i, c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是常数向量。每个约束对应电路中的一个门。</p>
<ul>
<li><strong>例子：</strong> 假设我们要证明你知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>5</mn><mo>=</mo><mn>35</mn></mrow><annotation encoding="application/x-tex">x^3 + x + 5 = 35</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">35</span></span></span></span>。
<ol>
<li>引入中间变量：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>1</mn></msub><mo>=</mo><mi>x</mi><mo>⋅</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">sym_1 = x \cdot x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>2</mn></msub><mo>=</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>1</mn></msub><mo>⋅</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">sym_2 = sym_1 \cdot x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>3</mn></msub><mo>=</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>2</mn></msub><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">sym_3 = sym_2 + x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>4</mn></msub><mo>=</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>3</mn></msub><mo>+</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">sym_4 = sym_3 + 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mo>=</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">out = sym_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>将其转换为 R1CS 约束 (向量表示)：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⋅</mo><mi>x</mi><mo>=</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>1</mn></msub><mspace width="1em"/><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \cdot x = sym_1 \quad \implies (x) \cdot (x) = (sym_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7194em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>1</mn></msub><mo>⋅</mo><mi>x</mi><mo>=</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>2</mn></msub><mspace width="1em"/><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sym_1 \cdot x = sym_2 \quad \implies (sym_1) \cdot (x) = (sym_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7194em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>2</mn></msub><mo>+</mo><mi>x</mi><mo>=</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>3</mn></msub><mspace width="1em"/><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>2</mn></msub><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sym_2 + x = sym_3 \quad \implies (sym_2 + x) \cdot (1) = (sym_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7194em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> (注意，加法通常通过乘以常数1来表示)</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>3</mn></msub><mo>+</mo><mn>5</mn><mo>=</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>4</mn></msub><mspace width="1em"/><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>3</mn></msub><mo>+</mo><mn>5</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sym_3 + 5 = sym_4 \quad \implies (sym_3 + 5) \cdot (1) = (sym_4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7194em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>4</mn></msub><mo>=</mo><mn>35</mn><mspace width="1em"/><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy="false">(</mo><mi>s</mi><mi>y</mi><msub><mi>m</mi><mn>4</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>35</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sym_4 = 35 \quad \implies (sym_4) \cdot (1) = (35)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6684em;vertical-align:-0.024em;"></span><span class="mord">35</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">sy</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">35</span><span class="mclose">)</span></span></span></span><br>
最终，通过一系列矩阵运算，将这些约束编码成多项式问题。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>Algebraic Intermediate Representation (AIR)</strong>：这是 zk-STARKs 中常用的编码方式，它将计算的每一步表示为多项式约束，并对整个计算轨迹的多项式表示施加低度检验。</p>
</li>
</ul>
<p>这种算术化是 ZKP 能够以代数方式进行证明和验证的基础。</p>
<h3 id="多项式承诺-Polynomial-Commitments">多项式承诺 (Polynomial Commitments)</h3>
<p>多项式承诺是现代 ZKP 的核心组件之一。它允许证明者“承诺”一个多项式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>，而无需透露该多项式的任何信息。之后，证明者可以“打开”这个承诺，揭示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 在某个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>，并提供一个简洁的证明，证明这个值确实是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 的取值。</p>
<p>多项式承诺需要满足两个关键属性：</p>
<ol>
<li><strong>绑定性 (Binding)</strong>：一旦证明者承诺了一个多项式，他就不能改变这个多项式而生成一个依然有效的打开证明。</li>
<li><strong>隐藏性 (Hiding)</strong>：在打开之前，承诺不会泄露关于多项式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 的任何信息。</li>
</ol>
<p><strong>常见的多项式承诺方案：</strong></p>
<ul>
<li>
<p><strong>KZG 承诺 (Kate, Zaverucha, Goldberg Commitment)</strong>：广泛用于 SNARKs。它基于配对友好椭圆曲线上的双线性映射（Pairing-friendly Elliptic Curves and Bilinear Pairings）。它的特点是：</p>
<ul>
<li>承诺本身是一个椭圆曲线上的点，尺寸是常数大小。</li>
<li>打开证明（评估证明）也是一个椭圆曲线上的点，尺寸是常数大小。</li>
<li>验证时间非常快。</li>
<li><strong>缺点：</strong> 依赖于一个“可信设置 (Trusted Setup)”过程，生成一个公共参考字符串（CRS）。如果CRS生成过程中产生了“毒性废料 (toxic waste)”（即秘密随机数），那么生成者理论上可以伪造任意证明。虽然有 MPC 协议来分布式地进行设置，但依然是潜在的信任问题。</li>
</ul>
</li>
<li>
<p><strong>FRI (Fast Reed-Solomon Interactive Oracle Proof of Proximity)</strong>：这是 zk-STARKs 的核心。它不依赖于椭圆曲线密码学，而是基于哈希函数和有限域上的多项式插值与低度测试。</p>
<ul>
<li><strong>优点：</strong> 无需可信设置，是透明的。对量子计算具有抵抗力。</li>
<li><strong>缺点：</strong> 证明尺寸比 KZG 承诺大，通常是对数级别，验证时间也稍长，但仍然比重新计算快很多。</li>
</ul>
</li>
</ul>
<p>理解了算术化和多项式承诺，我们就可以深入 zk-SNARKs 和 zk-STARKs 了。</p>
<h3 id="zk-SNARKs-简洁的非交互式论证知识零知识证明">zk-SNARKs: 简洁的非交互式论证知识零知识证明</h3>
<p><strong>全称：</strong> Zero-Knowledge Succinct Non-Interactive Argument of Knowledge</p>
<ul>
<li><strong>Zero-Knowledge (零知识)</strong>：证明者不泄露任何秘密信息。</li>
<li><strong>Succinct (简洁)</strong>：证明的尺寸非常小，验证时间非常快（常数时间）。这是它的最大亮点。</li>
<li><strong>Non-Interactive (非交互式)</strong>：证明者生成一次证明，验证者一次性验证。</li>
<li><strong>Argument of Knowledge (知识论证)</strong>：证明的可靠性基于计算假设（如离散对数问题等），而不是信息论上的无条件可靠。这意味着一个拥有足够计算能力的恶意证明者理论上可以伪造证明（但在实际中这种能力被认为是不可达的）。</li>
</ul>
<p><strong>工作原理概述：</strong></p>
<ol>
<li><strong>电路化 (Circuit Compilation)</strong>：将要证明的计算（例如，一个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x,w)=y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 是秘密证人）转换为 R1CS 形式。</li>
<li><strong>QAP 转换 (Quadratic Arithmetic Program)</strong>：将 R1CS 约束系统进一步转换为多项式问题。其核心思想是，如果所有 R1CS 约束都被满足，那么某个特定的目标多项式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 将能够整除另一个多项式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>。证明者需要证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 确实被 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 整除。</li>
<li><strong>多项式承诺 (Polynomial Commitment)</strong>：证明者计算出与 QAP 相关的多项式，并使用 KZG 承诺或其他多项式承诺方案对这些多项式进行承诺。</li>
<li><strong>知识论证 (Argument of Knowledge)</strong>：通过“知识的结构化参考字符串 (Structured Reference String, SRS)”（由可信设置生成），证明者可以生成一个简洁的证明，证明他对这些多项式进行了正确的承诺，并且它们满足了整除关系。</li>
<li><strong>验证 (Verification)</strong>：验证者利用 SRS 和承诺，通过少量椭圆曲线配对运算，快速验证证明的有效性。</li>
</ol>
<p><strong>代表性 zk-SNARK 方案：</strong></p>
<ul>
<li><strong>Groth16</strong>：目前生产环境中应用最广泛的 zk-SNARK。它具有非常小的证明尺寸（3个椭圆曲线点）和极快的验证时间，但需要一个计算特定电路的**“特异性”可信设置**。这意味着每个新的计算电路都需要重新进行一次可信设置。</li>
<li><strong>Plonk</strong>：支持**“通用且可更新”的可信设置**。这意味着一旦设置好，它可以用于任何电路，并且设置可以由多个参与者更新，每次更新都会生成新的秘密，降低单点失败的风险。证明尺寸和验证时间略大于Groth16，但灵活性大大提高。</li>
<li><strong>Marlin / Sonic / SuperSonic</strong>：也是通用设置的 SNARK，致力于提高证明生成效率或减少证明尺寸。</li>
</ul>
<p><strong>zk-SNARK 的优缺点：</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>极高的简洁性：</strong> 证明尺寸仅为数百字节，验证时间仅为几毫秒。</li>
<li><strong>隐私保护：</strong> 天生支持零知识性。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li><strong>可信设置问题：</strong> 许多 SNARKs 依赖于可信设置，这引入了对设置参与者的信任假设（即使是多方计算的设置）。如果“毒性废料”被保留，安全性将受到威胁。</li>
<li><strong>量子不安全：</strong> 依赖于椭圆曲线密码学，容易受到量子计算机的攻击。</li>
<li><strong>证明生成开销：</strong> 对于大型计算，证明生成过程可能非常耗时且内存密集。</li>
</ul>
</li>
</ul>
<h3 id="zk-STARKs-可扩展、透明的论证知识零知识证明">zk-STARKs: 可扩展、透明的论证知识零知识证明</h3>
<p><strong>全称：</strong> Zero-Knowledge Scalable Transparent Argument of Knowledge</p>
<ul>
<li><strong>Zero-Knowledge (零知识)</strong>：与 SNARKs 相同。</li>
<li><strong>Scalable (可扩展)</strong>：证明者时间（和内存）与计算大小呈拟线性关系（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>），而验证者时间（和证明大小）与计算大小呈对数关系（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log^2 N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1484em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>）。这使得它非常适合超大规模计算。</li>
<li><strong>Transparent (透明)</strong>：无需可信设置。证明生成过程完全公开可验证，依赖于抗碰撞哈希函数。</li>
<li><strong>Argument of Knowledge (知识论证)</strong>：与 SNARKs 相同。</li>
</ul>
<p><strong>工作原理概述：</strong><br>
zk-STARKs 的核心是利用了<strong>代数中间表示 (Algebraic Intermediate Representation, AIR)</strong> 和 <strong>FRI (Fast Reed-Solomon Interactive Oracle Proof of Proximity)</strong> 协议。</p>
<ol>
<li><strong>AIR 转换 (AIR Representation)</strong>：将计算转换为一系列多项式约束，这些约束在计算的每一步都必须满足。这会生成一个“执行轨迹”矩阵，其中包含了所有变量在计算每一步的值。</li>
<li><strong>多项式扩展 (Polynomial Extension)</strong>：将执行轨迹的每一列和每一行都看作一个多项式，并将其扩展到一个更大的域上。</li>
<li><strong>多项式承诺 (Polynomial Commitment)</strong>：使用 Merkle 树对这些扩展后的多项式进行承诺。由于是基于哈希函数，所以是透明的。</li>
<li><strong>FRI 协议 (Fast Reed-Solomon IOP of Proximity)</strong>：这是 STARKs 的核心创新。FRI 协议允许证明者向验证者证明一个给定的函数（由 Merkle 根承诺）是一个低次多项式。这是一个交互式协议，但通常通过 Fiat-Shamir 启发式转换为非交互式。它通过一系列多项式低度测试来逐渐降低多项式的次数，直到最终可以简单验证其为低次。</li>
<li><strong>验证 (Verification)</strong>：验证者通过 Merkle 路径和 FRI 证明，检查多项式承诺和低度证明是否有效。</li>
</ol>
<p><strong>zk-STARK 的优缺点：</strong></p>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>透明性：</strong> 无需可信设置，这消除了潜在的信任风险和操作复杂性。</li>
<li><strong>量子抵抗：</strong> 仅依赖于哈希函数和有限域上的多项式，对量子计算机具有抵抗力。</li>
<li><strong>可扩展性：</strong> 对于非常大的计算，其证明生成时间、证明大小和验证时间在渐进意义上优于许多 SNARKs，使其更适合大规模应用。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li><strong>证明大小：</strong> 通常比 SNARKs 大（几十到几百KB），但仍远小于原始计算。</li>
<li><strong>验证时间：</strong> 通常比 SNARKs 稍慢（几十到几百毫秒），但依然非常快。</li>
<li><strong>证明生成开销：</strong> 尽管渐进性好，但常数因子可能较大，特别是内存消耗。</li>
</ul>
</li>
</ul>
<h3 id="总结与对比：SNARKs-vs-STARKs">总结与对比：SNARKs vs STARKs</h3>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">zk-SNARKs</th>
<th style="text-align:left">zk-STARKs</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>可信设置</strong></td>
<td style="text-align:left">多数需要 (如 Groth16)，部分支持通用可更新 (如 Plonk)</td>
<td style="text-align:left">不需要，完全透明</td>
</tr>
<tr>
<td style="text-align:left"><strong>量子安全</strong></td>
<td style="text-align:left">不安全 (基于椭圆曲线)</td>
<td style="text-align:left">安全 (基于哈希函数)</td>
</tr>
<tr>
<td style="text-align:left"><strong>证明大小</strong></td>
<td style="text-align:left">极小 (数百字节)</td>
<td style="text-align:left">相对较大 (几十到几百 KB)，但仍是 对数级别</td>
</tr>
<tr>
<td style="text-align:left"><strong>验证时间</strong></td>
<td style="text-align:left">极快 (几毫秒)</td>
<td style="text-align:left">相对较快 (几十到几百毫秒)</td>
</tr>
<tr>
<td style="text-align:left"><strong>证明生成</strong></td>
<td style="text-align:left">对于大计算可能效率不高，或内存密集</td>
<td style="text-align:left">渐进可扩展，对于大计算表现更好</td>
</tr>
<tr>
<td style="text-align:left"><strong>应用场景</strong></td>
<td style="text-align:left">区块链扩容 (zk-Rollups), 隐私交易 (Zcash), 较小计算验证</td>
<td style="text-align:left">区块链扩容 (zk-Rollups), 大规模计算验证，更强透明性需求</td>
</tr>
</tbody>
</table>
<p>选择 SNARK 还是 STARK 取决于具体的应用场景和需求。如果对证明尺寸和验证时间有极致要求，并且可以接受可信设置，那么 SNARKs 可能是首选。如果对透明性、量子安全性和大规模计算的可扩展性有更高要求，那么 STARKs 更具优势。</p>
<p>在下一章中，我们将探讨这些前沿技术如何催生新的应用范式，以及它们面临的挑战。</p>
<h2 id="第五章：高级主题与前沿应用">第五章：高级主题与前沿应用</h2>
<p>可验证计算和零知识证明的理论研究和工程实践正在日新月异。从基础协议的优化到各种创新性应用的落地，这个领域充满了活力。</p>
<h3 id="递归证明：证明的证明">递归证明：证明的证明</h3>
<p><strong>概念：</strong> 递归证明（Recursive Proofs），或称证明聚合（Proof Aggregation），是指一个零知识证明本身可以作为另一个零知识证明的输入。简单来说，就是“证明一个证明的有效性”。</p>
<ul>
<li><strong>工作原理：</strong> 一个 ZKP 协议的验证器电路被另一个 ZKP 协议的证明者所“包装”，即证明者生成一个证明，证明它已经正确地验证了前一个证明。</li>
<li><strong>优势：</strong>
<ul>
<li><strong>无限可扩展性：</strong> 能够将任意数量的证明“压缩”成一个单一的、简洁的证明。例如，可以证明100万个交易的状态转换是正确的，而验证者只需要验证一个最终的简洁证明。这对于区块链的长期状态同步和历史数据存储具有革命性意义。</li>
<li><strong>链下计算的证明聚合：</strong> 大量的链下计算可以递归地聚合为一个总证明，最终只将这个总证明提交到链上进行验证。</li>
<li><strong>链上隐私：</strong> 允许将私有交易捆绑在一起，生成一个证明，然后将这个证明作为输入提交给下一个证明。</li>
</ul>
</li>
<li><strong>代表性方案：</strong>
<ul>
<li><strong>Halo / Halo2</strong>：第一个真正实现了无需可信设置的递归 ZKP，由 Zcash 团队开发。</li>
<li><strong>Nova</strong>：另一个重要的递归 ZKP 方案，在 prover 端的效率很高，特别适用于增量计算（Incremental Computation）。</li>
<li><strong>CycleFold</strong>：结合了多种椭圆曲线的特性，用于实现高效的递归。</li>
</ul>
</li>
</ul>
<p>递归证明是目前 ZKP 领域最激动人心的进展之一，它解锁了以前无法想象的可扩展性水平。</p>
<h3 id="链上应用：zk-Rollups-与-zkEVM">链上应用：zk-Rollups 与 zkEVM</h3>
<p>区块链的可扩展性问题是 ZKP 技术最直接也最受关注的应用场景。</p>
<ul>
<li>
<p><strong>zk-Rollups</strong>：这是以太坊 Layer 2 扩容方案中最有前景的技术之一。</p>
<ul>
<li><strong>工作原理：</strong> 大量交易在链下执行和聚合，然后由一个 zk-Rollup 节点（证明者）生成一个包含所有这些交易有效性的零知识证明。这个证明被提交到以太坊主网（Layer 1）上的一个智能合约（验证者）进行验证。智能合约只需要验证这个单一的简洁证明，而不是每一笔交易。同时，交易数据（或者其压缩版本）也发布到链上，以确保数据可用性（Data Availability），从而保证资金安全。</li>
<li><strong>优势：</strong> 极大地提高了交易吞吐量，降低了交易费用，同时继承了以太坊主网的安全性（因为验证发生在 Layer 1）。</li>
<li><strong>主要项目：</strong> zkSync (Matter Labs), StarkWare (StarkNet), Polygon zkEVM, Scroll。这些项目都在构建各自的 zk-Rollup 解决方案，目标是实现<strong>zkEVM</strong>。</li>
</ul>
</li>
<li>
<p><strong>zkEVM (Zero-Knowledge Ethereum Virtual Machine)</strong>：</p>
<ul>
<li><strong>概念：</strong> 能够证明以太坊虚拟机（EVM）执行的每一步都是正确且遵守规则的零知识证明系统。</li>
<li><strong>意义：</strong> 如果一个 zk-Rollup 能够兼容 EVM，那么现有的以太坊智能合约和去中心化应用（dApps）就可以直接迁移到 zk-Rollup 上，享受高吞吐量和低费用的优势，而无需修改代码。这是实现以太坊扩容的“圣杯”。</li>
<li><strong>挑战：</strong> EVM 的复杂指令集和状态转换对于 ZKP 电路设计来说是巨大的挑战。将 EVM 执行算术化成 ZKP 友好的形式非常复杂且计算量大。</li>
<li><strong>类型：</strong> 根据与 EVM 的兼容性程度，zkEVMs 被分为不同的类型（Type 1, Type 2, Type 3, Type 4），Type 1 是最兼容的（无需修改任何 EVM 代码即可运行），但实现难度最大。</li>
</ul>
</li>
</ul>
<h3 id="零知识机器学习-ZKML">零知识机器学习 (ZKML)</h3>
<p><strong>概念：</strong> 在机器学习的训练或推理过程中应用零知识证明技术，以实现隐私保护和模型验证。</p>
<ul>
<li><strong>隐私推理：</strong> 证明者可以向验证者证明其模型在给定的私有输入上产生了某个特定的预测结果，而无需透露模型权重（知识产权）或用户的私有输入数据。例如，证明“我的信用评分高于某个阈值”，而无需透露具体的信用评分或收入。</li>
<li><strong>模型审计/合规：</strong> 监管机构可以验证模型的公平性、是否存在偏见，而无需访问模型的内部结构。</li>
<li><strong>链上 AI：</strong> 将 AI 模型推理的证明提交到区块链上，用于去中心化预言机、链上游戏或 DeFi 策略。</li>
<li><strong>挑战：</strong> 机器学习模型通常涉及大量的浮点运算和非线性激活函数，将其高效地转换为 ZKP 友好的算术电路是一个巨大的工程挑战。需要开发专门的电路优化技术和近似算法。</li>
</ul>
<h3 id="隐私身份与可验证凭证">隐私身份与可验证凭证</h3>
<p><strong>概念：</strong> 利用 ZKP 证明身份属性，而无需泄露完整的身份信息。</p>
<ul>
<li><strong>数字身份：</strong> 你可以证明你是某个组织的成员，而无需透露你的姓名、邮箱等。</li>
<li><strong>年龄验证：</strong> 证明你的年龄大于18岁，而无需透露你的出生日期。</li>
<li><strong>零知识 KYC (Know Your Customer)：</strong> 金融机构可以验证用户的 KYC 信息（如身份、住址），而无需长期存储这些敏感信息，从而降低数据泄露风险。</li>
<li><strong>可验证凭证 (Verifiable Credentials, VC)：</strong> 与去中心化标识符（DID）结合，ZKP 允许用户拥有和控制自己的数字凭证，并在需要时选择性地披露特定属性的证明。</li>
</ul>
<h3 id="其他新兴应用">其他新兴应用</h3>
<ul>
<li><strong>零知识桥接 (ZK Bridges)</strong>：实现不同区块链之间的安全、无需信任的资产跨链，通过 ZKP 证明目标链上的状态转换。</li>
<li><strong>去中心化存储证明 (Proof of Retrievability/Storage)</strong>：在去中心化存储网络（如 Filecoin）中，证明者（存储提供商）可以通过 ZKP 证明他们确实存储了某个文件，而无需下载整个文件。</li>
<li><strong>私人投票系统 (Private Voting)</strong>：ZKP 可以确保投票的匿名性，同时确保投票的有效性和结果的正确性。</li>
</ul>
<h3 id="挑战与未来展望">挑战与未来展望</h3>
<p>尽管 ZKP 领域发展迅猛，但仍面临一些挑战：</p>
<ol>
<li><strong>证明生成性能：</strong> 对于复杂计算，证明生成仍然是计算密集型和内存密集型的，需要强大的硬件支持。</li>
<li><strong>电路开发复杂性：</strong> 将任意程序转换为 ZKP 友好的算术电路需要专业的技能和复杂的工具链。这对于开发者来说是一个很高的门槛。</li>
<li><strong>安全性审计：</strong> ZKP 电路一旦部署，其安全性至关重要。需要严格的形式化验证和审计流程来确保没有漏洞。</li>
<li><strong>互操作性和标准化：</strong> 不同的 ZKP 方案和实现之间缺乏互操作性，不利于生态系统的统一发展。</li>
<li><strong>教育和普及：</strong> ZKP 的概念非常抽象和复杂，需要更多的人才投入研究和开发，也需要更通俗易懂的教育资源来普及。</li>
</ol>
<p>尽管存在这些挑战，零知识证明和可验证计算的潜力是巨大的。它们不仅仅是密码学工具，更是构建下一代互联网基础设施、实现数据主权和隐私保护、以及提升全球计算效率的关键技术。我们可以预见到一个未来：在这个未来中，信任不再是假设，而是通过数学证明强制执行；数据隐私得到保障，而协作和创新得以蓬勃发展；计算不再受限于集中式服务器，而是可以在全球分布式网络中高效、可信地进行。</p>
<h2 id="第六章：实践工具与生态系统">第六章：实践工具与生态系统</h2>
<p>如果你被零知识证明和可验证计算的潜力所吸引，并想亲自动手尝试，那么了解当前活跃的工具和开发框架是必不可少的。虽然 ZKP 的开发仍然相对复杂，但生态系统正在快速成熟。</p>
<h3 id="1-电路编程语言与框架">1. 电路编程语言与框架</h3>
<p>由于 ZKP 需要将通用计算转换为特定的算术电路形式，所以诞生了专门用于描述 ZKP 电路的编程语言或 DSL（领域特定语言）。</p>
<ul>
<li>
<p><strong>Circom (Circuit Compiler)</strong>：</p>
<ul>
<li><strong>特点：</strong> 一种专门为零知识证明设计的类 JavaScript 语言。它允许开发者以一种相对直观的方式定义算术电路，并生成 R1CS（Rank-1 Constraint System）和 Wasm 文件，用于 SNARKs 证明。</li>
<li><strong>优势：</strong> 拥有庞大的社区和丰富的模板库（如 circomlib），特别适合入门和开发基于 SNARK 的应用。广泛用于 DeFi 和其他隐私应用。</li>
<li><strong>典型工作流：</strong> 编写 <code>.circom</code> 文件 -&gt; 使用 <code>circom</code> 编译器生成 R1CS 和 Witness Generator -&gt; 使用 <code>snarkjs</code> (JavaScript) 或 <code>bellman</code> (Rust) 等工具进行证明生成和验证。</li>
<li><strong>示例 (Circom):</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// circom-example.circom</span><br><span class="line">pragma circom 2.0.0;</span><br><span class="line"></span><br><span class="line">// Proves knowledge of x and y such that x*x + y*y = z</span><br><span class="line">template PythagoreanTheorem() &#123;</span><br><span class="line">    // Input signals (public by default, can be private)</span><br><span class="line">    signal input x;</span><br><span class="line">    signal input y;</span><br><span class="line">    // Public output signal</span><br><span class="line">    signal output z;</span><br><span class="line"></span><br><span class="line">    // Internal signals for intermediate products</span><br><span class="line">    signal x_squared;</span><br><span class="line">    signal y_squared;</span><br><span class="line">    signal sum_of_squares;</span><br><span class="line"></span><br><span class="line">    // Constraints:</span><br><span class="line">    // x_squared = x * x</span><br><span class="line">    x_squared &lt;== x * x; // &lt;== is the constraint operator</span><br><span class="line">    // y_squared = y * y</span><br><span class="line">    y_squared &lt;== y * y;</span><br><span class="line">    // sum_of_squares = x_squared + y_squared</span><br><span class="line">    sum_of_squares &lt;== x_squared + y_squared;</span><br><span class="line">    // z = sum_of_squares</span><br><span class="line">    z &lt;== sum_of_squares;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">component main = PythagoreanTheorem();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>Halo2 (由 Zcash/Electric Coin Co. 开发)</strong>：</p>
<ul>
<li><strong>特点：</strong> 一个用 Rust 编写的 ZKP 框架，实现了 Halo2 协议。它是一个基于多项式承诺和查找表（lookup arguments）的通用 SNARK，最大的特点是无需可信设置（或者说，它是一个可更新的、增量的、循环的 SNARK，允许递归证明）。</li>
<li><strong>优势：</strong> 强大的递归证明能力，高度优化，灵活性强，适合构建复杂的链上扩容方案（如 zkEVMs）。</li>
<li><strong>典型工作流：</strong> 使用 Rust 编写电路（通过一系列 <code>Gate</code> 和 <code>Cell</code> 抽象） -&gt; <code>halo2_proofs</code> 库生成证明 -&gt; <code>halo2_proofs</code> 库验证证明。</li>
<li><strong>复杂性：</strong> 学习曲线陡峭，更适合有深入密码学和 Rust 编程经验的开发者。</li>
</ul>
</li>
<li>
<p><strong>Cairo (由 StarkWare 开发)</strong>：</p>
<ul>
<li><strong>特点：</strong> 专为 STARK 证明设计的图灵完备编程语言。它是 StarkWare 生态系统的核心，用于编写运行在 StarkNet (zk-Rollup) 上的智能合约和应用程序。</li>
<li><strong>优势：</strong> 与 STARKs 紧密集成，是为可扩展性而设计的。StarkNet 上的应用直接用 Cairo 编写，其执行可以直接生成 STARK 证明。</li>
<li><strong>典型工作流：</strong> 编写 Cairo 代码 -&gt; Cairo VM 执行 -&gt; 生成 trace -&gt; StarkWare prover 生成 STARK 证明 -&gt; 提交到链上验证。</li>
<li><strong>复杂性：</strong> 同样需要学习新的编程语言和范式。</li>
</ul>
</li>
<li>
<p><strong>gnark (由 ConsenSys 开发)</strong>：</p>
<ul>
<li><strong>特点：</strong> 一个用 Go 编写的 ZKP 库，支持多种 SNARK 方案（如 Groth16, Plonk）。它提供了高级 API 来定义算术电路。</li>
<li><strong>优势：</strong> 简洁的 Go API，性能优秀，适合 Go 开发者。</li>
</ul>
</li>
</ul>
<h3 id="2-ZKP-开发辅助工具">2. ZKP 开发辅助工具</h3>
<ul>
<li><strong>snarkjs</strong>：一个基于 JavaScript 的库，用于与 Circom 编译器生成的 R1CS 和 Wasm 文件交互，进行证明生成、验证和可信设置（对于 Groth16）。是 Circom 开发者的好帮手。</li>
<li><strong>Proof Marketplaces/Aggregators</strong>：未来可能会出现专业的服务，允许用户提交计算任务，由专业证明者集群生成证明，并聚合，降低个人/项目的证明生成成本。</li>
<li><strong>调试和优化工具</strong>：ZKP 电路中的 bug 很难发现，性能瓶颈也很常见。因此，正在开发专门的工具来分析电路的约束数量、验证内存使用、并帮助开发者优化电路。例如，Circom 社区有一些可视化工具和 Gas 估算工具。</li>
</ul>
<h3 id="3-应用层框架与-SDKs">3. 应用层框架与 SDKs</h3>
<p>许多项目正在构建更高级别的 SDK，以简化 ZKP 在特定应用中的集成。</p>
<ul>
<li><strong>隐私中间件</strong>：提供抽象层，让开发者无需直接与复杂的 ZKP 电路交互，即可实现隐私保护功能（例如，隐私投票、隐私支付）。</li>
<li><strong>zk-Rollup SDKs</strong>：例如，zkSync 或 Polygon zkEVM 提供的开发套件，允许开发者在他们的 Layer 2 网络上部署智能合约，并利用底层的 ZKP 技术进行扩容。</li>
<li><strong>ZKML 框架</strong>：如 <code>Ezkl</code> 等，旨在将机器学习模型（如 PyTorch 模型）转换为 ZKP 友好的表示，从而能够生成 ML 推理的零知识证明。</li>
</ul>
<h3 id="4-挑战与展望">4. 挑战与展望</h3>
<p>尽管工具生态系统在不断进步，但 ZKP 开发仍然面临挑战：</p>
<ul>
<li><strong>高性能要求：</strong> 证明生成通常需要强大的计算资源（CPU、内存），有时甚至需要专门的硬件加速（如 GPU 或 ASIC）。</li>
<li><strong>学习曲线陡峭：</strong> ZKP 涉及复杂的密码学和数学概念，以及独特的编程范式，使得入门门槛较高。</li>
<li><strong>安全性考量：</strong> 电路中的任何小错误都可能导致严重的密码学漏洞。形式化验证和严格的代码审计至关重要。</li>
<li><strong>通用性与效率的权衡：</strong> 将通用计算转换为高效的 ZKP 电路仍然是一个研究活跃的领域。</li>
</ul>
<p>未来，我们期待看到：</p>
<ul>
<li><strong>更高级的抽象层：</strong> 允许开发者使用更熟悉的语言（如 Rust、Python）编写通用程序，然后由编译器自动将其转换为 ZKP 电路，并进行优化。</li>
<li><strong>硬件加速的普及：</strong> 专门的 ZKP 证明器硬件（ASIC）可能会出现，极大地降低证明生成的成本和时间。</li>
<li><strong>更成熟的调试和审计工具：</strong> 提高 ZKP 应用的开发效率和安全性。</li>
<li><strong>更广泛的行业采用：</strong> 随着技术成熟和成本下降，ZKP 将渗透到更多传统行业，从金融到医疗，从供应链到物联网。</li>
</ul>
<p>零知识证明的实践之路虽然充满挑战，但其带来的变革性潜力是无法估量的。作为技术爱好者，参与到这个领域的研究和开发中，将是塑造未来数字世界的重要一步。</p>
<h2 id="结论：构建一个可信、隐私、可扩展的数字未来">结论：构建一个可信、隐私、可扩展的数字未来</h2>
<p>我们已经走过了一段深入可验证计算和零知识证明的旅程，从理解它们解决的核心问题——信任、可扩展性和隐私，到探索它们的基础密码学原理，再到它们在 zk-SNARKs 和 zk-STARKs 中的具体实现，以及它们在区块链、人工智能和隐私身份等前沿领域中催生的革命性应用。</p>
<p>可验证计算和零知识证明不仅仅是密码学领域的奇迹，它们更是构建下一代互联网基础设施的关键技术。它们共同描绘了一个激动人心的未来：</p>
<ul>
<li><strong>一个无需信任的计算世界：</strong> 我们不再需要盲目信任中心化的权威或昂贵的审计过程。通过数学和密码学的力量，计算的正确性可以在任何地方、任何时间以极低的成本进行验证。</li>
<li><strong>一个无限可扩展的数字生态：</strong> 复杂计算可以被压缩、聚合，并以简洁的证明形式在链上或分布式系统中高效验证，突破了传统系统的性能瓶颈。</li>
<li><strong>一个隐私至上的数字身份：</strong> 个人可以精确控制自己的数据，在需要证明某个属性时，只揭示必要的信息，而不会泄露任何额外细节，从而实现真正的数字主权。</li>
</ul>
<p>当然，ZKP 领域仍然年轻，挑战犹存。证明生成的计算开销、电路开发的复杂性、以及对量子计算的长期抵抗力都是当前研究和工程实践的重点。然而，随着全球顶尖的密码学家、计算机科学家和工程师的持续投入，这些挑战正在被逐一攻克。新的协议、更高效的算法、以及更友好的开发工具正在不断涌现。</p>
<p>作为一名技术博主，我见证了无数次技术浪潮的兴起，但我相信，零知识证明所代表的范式转变，将对社会产生深远的影响。它不仅仅是关于区块链的扩容，更是关于如何重新定义我们在数字世界中的信任关系，如何平衡效率与安全，以及如何在日益复杂的数据环境中保护我们的基本权利。</p>
<p>如果你对未来充满好奇，对技术变革充满热情，那么我鼓励你深入探索这个领域。无论是通过阅读最新的研究论文，参与开源项目，还是亲自动手编写第一个 ZKP 电路，每一点努力都将是推动这个信任新纪元到来的重要贡献。</p>
<p>感谢你的阅读，期待在未来的技术探索中再次相遇！</p>
<p>qmwneb946<br>
2023年10月27日</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/qmwneb946">qmwneb946</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qmwneb946.dpdns.org/2025/07/22/2025-07-22-170440/">https://qmwneb946.dpdns.org/2025/07/22/2025-07-22-170440/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a> 许可协议。转载请注明来源 <a href="https://qmwneb946.dpdns.org" target="_blank">qmwneb946 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/%E5%8F%AF%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97%E4%B8%8E%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/">可验证计算与零知识证明</a></div><div class="post-share"><div class="social-share" data-image="/img/icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/22/2025-07-22-170545/" title="预言机：打开区块链“封闭宇宙”的钥匙"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">预言机：打开区块链“封闭宇宙”的钥匙</div></div><div class="info-2"><div class="info-item-1">大家好，我是 qmwneb946，一名热爱技术与数学，并致力于探索区块链奥秘的博主。今天，我们将深入探讨一个在区块链世界中至关重要，却又常常被误解或忽视的角色——“预言机”（Oracle）。 引言：区块链的“薛定谔之猫”与对外部世界的渴望 想象一下，我们身处一个由严密数学和密码学规则构建的完美数字堡垒——区块链。在这里，一切都确定无疑，交易透明可查，智能合约一丝不苟地执行着预设的逻辑。这是一个自洽的、去中心化的“封闭宇宙”。它的美在于其内在的确定性、抗审查性和不可篡改性。然而，这种封闭性也带来了一个根本性的限制：它无法感知或验证外部世界的真实事件。 智能合约，其核心是“如果X发生，则执行Y”。但这里的“X”必须是链上可验证的事件。例如，“如果账户A向账户B转账10个ETH，则执行C”，这完全没问题，因为转账本身就是链上事件。但是，如果我们需要执行“如果波音737航班延误超过3小时，则自动赔付乘客保险金”，“如果ETH/USD价格跌破2000美元，则强制清算抵押品”，或者“如果某足球队赢得比赛，则自动分发奖金”，这些“X”条件都来自于链下世界。区块链本身无法知道航班是否延误，也无法...</div></div></div></a><a class="pagination-related" href="/2025/07/22/2025-07-22-170321/" title="深度强化学习的样本效率：通往智能体普适性的基石"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">深度强化学习的样本效率：通往智能体普适性的基石</div></div><div class="info-2"><div class="info-item-1">你好，各位技术爱好者和好奇的探险家！我是 qmwneb946，很高兴能再次与大家相聚，共同探索人工智能领域最前沿、也最具挑战性的议题。今天，我们将深入探讨一个在深度强化学习（DRL）中至关重要的概念——样本效率 (Sample Efficiency)。 强化学习，特别是当它与深度学习相结合时，在过去十年中取得了令人瞩目的成就，从在围棋桌上战胜人类冠军到控制机器人进行复杂操作，其潜力无疑是巨大的。然而，这些突破的背后，往往是海量数据和计算资源的支撑。想象一下，一个智能体需要数百万甚至数十亿次与环境的互动才能学会一个任务，这在许多现实世界场景中是不可接受的，甚至是危险的。这正是样本效率问题所在，也是我们今天聚焦的核心。 我们将从强化学习的基础出发，逐步剖析样本效率的定义、它为何如此重要，以及导致其低下的根本原因。更重要的是，我们将详细探讨当前最前沿的、旨在提升样本效率的各种策略和方法，从基础的经验回放到复杂的基于模型和分层学习范式。我希望通过今天的分享，不仅能让你对DRL的现状有更深刻的理解，也能激发你对未来智能体发展方向的思考。 准备好了吗？让我们一起踏上这场充满挑战与机遇的旅程！...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/18/2025-07-18-082448/" title="数据挖掘在金融风控的应用：从算法到实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">数据挖掘在金融风控的应用：从算法到实践</div></div><div class="info-2"><div class="info-item-1">大家好，我是你们的技术博主，今天我们来深入探讨一个与我们日常生活息息相关，却又充满技术挑战的领域：金融风控。在这个领域中，数据挖掘技术发挥着越来越重要的作用，它帮助金融机构有效识别和管理风险，保障金融体系的稳定运行。本文将从多个角度深入探讨数据挖掘在金融风控中的应用，并结合实际案例进行分析。 数据挖掘在金融风控中的关键作用 金融风控的目标是识别、评估和控制各种金融风险，例如信用风险、欺诈风险、操作风险等。传统的风控方法往往依赖于人工审核和简单的统计模型，效率低、准确率不高。而数据挖掘技术的出现，为金融风控带来了革命性的变革。它能够从海量数据中提取有价值的信息，建立更精确的风险模型，从而提高风控效率和准确性。 具体来说，数据挖掘在金融风控中主要发挥以下作用： 欺诈检测 欺诈行为日益猖獗，给金融机构造成巨大的经济损失。数据挖掘技术，特别是异常检测算法，能够有效识别出可疑交易行为。例如，基于机器学习的异常检测模型可以学习正常交易的模式，然后识别偏离该模式的异常交易，从而有效识别潜在的欺诈行为。常用的算法包括：  孤立森林 (Isolation Forest): 通过随机分割数据来隔离异...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082509/" title="虚拟现实技术的沉浸式体验：从感知到认知"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">虚拟现实技术的沉浸式体验：从感知到认知</div></div><div class="info-2"><div class="info-item-1">虚拟现实（VR）技术不再是科幻小说中的幻想，它已经逐渐融入我们的生活，并正在深刻地改变着我们与世界互动的方式。本文将深入探讨VR技术的沉浸式体验，从技术原理到感知机制，再到其潜在的应用和未来发展方向，为技术爱好者提供一个全面的视角。 沉浸式体验的奥秘：技术层面 VR技术能够创造出令人信服的沉浸式体验，这依赖于多项关键技术的协同作用。 显示技术与图像渲染 高质量的图像渲染是VR体验的关键。高分辨率、高刷新率的显示器能够有效减少画面延迟和模糊感，提升视觉舒适度。目前主流的VR头显大多采用OLED或LCD屏幕，并通过透镜系统将图像投射到用户的视网膜上，模拟真实世界的视觉体验。  为了实现更广阔的视野（FOV），厂商们也在不断改进透镜设计和显示面板技术。 空间音频技术 除了视觉，听觉在构建沉浸式环境中也扮演着至关重要的角色。空间音频技术通过模拟声音在三维空间中的传播，让用户能够准确感知声音的方位和距离，增强临场感。例如，头部追踪技术配合精密的算法，可以根据用户头部姿态实时调整声音的输出，使声音效果更加逼真。 追踪技术与交互方式 精确的追踪技术是VR体验流畅的关键。目前常用的追踪技术包括：...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082730/" title="有机合成中的手性催化技术：构建分子世界的精巧艺术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">有机合成中的手性催化技术：构建分子世界的精巧艺术</div></div><div class="info-2"><div class="info-item-1">有机合成，这门将简单的化学物质转化为复杂分子的艺术，正因手性分子的存在而变得更加精妙和挑战性。手性分子如同左右手一样，结构互为镜像，但性质却可能大相径庭。在药物研发、材料科学等领域，获得特定手性的分子至关重要，而手性催化技术正是实现这一目标的关键。本文将深入探讨有机合成中的手性催化技术，揭示其背后的原理和应用。 手性与手性催化：从镜像到精准控制 手性，源于希腊语“cheir”（手），指的是分子不能与其镜像重合的特性。这种结构差异导致手性分子具有不同的物理性质和生物活性。例如，一种药物的左旋体可能具有疗效，而其右旋体则可能无效甚至有害。因此，精准控制手性合成至关重要。 手性催化技术利用手性催化剂来控制反应的立体选择性，即优先生成特定手性的产物。催化剂本身是手性的，它通过与反应物形成短暂的超分子复合物，影响反应路径，从而引导反应朝特定立体异构体方向进行。这就好比一个熟练的工匠，用巧妙的手法引导反应物“组装”成预期的分子结构。 手性催化剂的类型及作用机制 目前，广泛应用的手性催化剂主要包括： 过渡金属配合物催化剂 这类催化剂通常含有手性配体与过渡金属中心（如铑、钌、钯等）结合而成。配体...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082852/" title="光谱分析技术在环境监测的应用：从原理到实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">光谱分析技术在环境监测的应用：从原理到实践</div></div><div class="info-2"><div class="info-item-1">大家好，我是你们的技术博主 DataWhisperer！今天我们来聊一个既高大上又贴近生活的技术领域：光谱分析技术在环境监测中的应用。  这可不是简单的“看看颜色”就能搞定的，它背后蕴含着丰富的物理学、化学和数学原理，并且在保护我们的环境方面发挥着越来越重要的作用。 引言：光谱分析 – 环境监测的“火眼金睛” 环境监测的目标是及时、准确地获取环境污染物的信息，为环境保护和管理提供科学依据。传统监测方法往往费时费力，且灵敏度有限。而光谱分析技术，凭借其快速、灵敏、多组分同时检测等优点，成为了环境监测领域的一匹黑马。  它利用物质与电磁辐射相互作用的特性，分析物质的成分和结构，从而实现对环境污染物的精准识别和定量分析。 光谱分析技术的种类及原理 光谱分析技术涵盖多种方法，根据所用电磁波的波长范围不同，可以分为： 紫外-可见光谱法 (UV-Vis) UV-Vis 光谱法利用物质对紫外和可见光区域电磁波的吸收特性进行分析。  不同物质具有独特的吸收光谱，通过测量吸收光谱的特征峰，可以确定物质的种类和浓度。  这在水质监测中应用广泛，例如检测重金属离子、有机污染物等。  其原理基于朗伯-比...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082903/" title="计算化学模拟分子间相互作用：从经典力场到量子力学"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">计算化学模拟分子间相互作用：从经典力场到量子力学</div></div><div class="info-2"><div class="info-item-1">引言 分子间相互作用是化学和生物学领域的核心概念，它支配着物质的物理和化学性质，例如溶解度、沸点、蛋白质折叠等等。精确地模拟这些相互作用对于理解和预测分子行为至关重要。计算化学为我们提供了一套强大的工具来研究分子间相互作用，从经典的力场方法到复杂的量子力学计算，本文将深入探讨这些方法及其应用。 经典力场方法 经典力场方法基于牛顿力学，将分子简化为一系列原子，并通过经验参数化的势能函数来描述原子间的相互作用。这种方法计算效率高，适用于模拟大量的原子和分子，例如蛋白质、DNA和材料科学中的大分子体系。 势能函数 经典力场通常包含以下几种类型的相互作用项：  键伸缩 (Bond Stretching): 描述键长偏离平衡键长的能量变化，通常用谐振势能函数表示：Ebond=12kb(r−r0)2E_{bond} = \frac{1}{2}k_b(r - r_0)^2Ebond​=21​kb​(r−r0​)2，其中 kbk_bkb​ 是力常数，rrr 是键长，r0r_0r0​ 是平衡键长。 键角弯曲 (Angle Bending): 描述键角偏离平衡键角的能量变化，通常也用谐振势能函数表示...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082912/" title="绿色化学与可持续发展目标：技术与未来的融合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">绿色化学与可持续发展目标：技术与未来的融合</div></div><div class="info-2"><div class="info-item-1">近年来，可持续发展已成为全球关注的焦点，联合国提出的17个可持续发展目标 (SDGs) 为全球共同努力提供了蓝图。其中，许多目标都与化学工业息息相关，而绿色化学作为一种旨在减少或消除有害物质使用的化学方法，扮演着至关重要的角色。本文将探讨绿色化学如何为实现可持续发展目标做出贡献，并从技术角度深入分析其应用。 绿色化学的十二原则：通向可持续未来的基石 绿色化学的核心是其十二项原则，这些原则指导着化学家的研究和工业生产，力求最大限度地减少环境影响。这些原则并非相互独立，而是相互关联，共同构成了一个整体的框架。 预防原则 这是绿色化学的首要原则，强调在化学反应的设计阶段就应避免产生有害物质，而非在产生后进行处理。这需要化学家们从根本上重新思考化学反应的设计和工艺流程。 原子经济性 理想情况下，所有反应物原子都应转化为最终产物，没有任何浪费。原子经济性是衡量化学反应效率的重要指标，其计算公式为： 原子经济性=目标产物的分子量所有反应物的分子量总和×100%原子经济性 = \frac{目标产物的分子量}{所有反应物的分子量总和} \times 100\%原子经济性=所有反应物的分子量总和目...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">qmwneb946</div><div class="author-info-description">一个专注于技术分享的个人博客，涵盖编程、算法、系统设计等内容</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">683</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">687</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qmwneb946"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/qmwneb946" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:qmwneb946@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">代码与远方，技术与生活交织的篇章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BF%A1%E4%BB%BB%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E4%B8%8E%E9%9A%90%E7%A7%81%E7%9A%84%E5%9B%B0%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">第一章：信任、可扩展性与隐私的困境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E4%BB%BB%E5%8D%B1%E6%9C%BA%EF%BC%9A%E6%88%91%E4%BB%AC%E8%83%BD%E7%9B%B8%E4%BF%A1%E8%B0%81%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">信任危机：我们能相信谁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E7%93%B6%E9%A2%88%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9A%84%E6%9E%B7%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">可扩展性瓶颈：性能的枷锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E7%A7%81%E6%B3%84%E9%9C%B2%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A3%B8%E5%A5%94"><span class="toc-number">1.3.</span> <span class="toc-text">隐私泄露：数据的裸奔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97%E4%B8%8E%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%EF%BC%9A%E5%B8%8C%E6%9C%9B%E4%B9%8B%E5%85%89"><span class="toc-number">1.4.</span> <span class="toc-text">可验证计算与零知识证明：希望之光</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%8F%AF%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97%EF%BC%9A%E5%AE%A1%E8%AE%A1%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">第二章：可验证计算：审计未来的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是可验证计算？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%8F%AF%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">为什么我们需要可验证计算？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">可验证计算的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AF%81%E6%98%8E%E7%B3%BB%E7%BB%9F-Interactive-Proof-Systems-IPS"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 交互式证明系统 (Interactive Proof Systems, IPS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AF%81%E6%98%8E%E7%B3%BB%E7%BB%9F-Non-Interactive-Proof-Systems-NIPS"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 非交互式证明系统 (Non-Interactive Proof Systems, NIPS)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><span class="toc-number">2.4.</span> <span class="toc-text">可验证计算的核心挑战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%EF%BC%9A%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-number">3.</span> <span class="toc-text">第三章：零知识证明：隐私保护的艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">什么是零知识证明？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZKP-%E7%9A%84%E2%80%9C%E4%B8%89%E6%80%A7%E2%80%9D"><span class="toc-number">3.2.</span> <span class="toc-text">ZKP 的“三性”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E2%80%9C%E6%B4%9E%E7%A9%B4%E6%AF%94%E5%96%BB%E2%80%9D"><span class="toc-number">3.3.</span> <span class="toc-text">经典的“洞穴比喻”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">零知识证明的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E-Interactive-ZKP"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. 交互式零知识证明 (Interactive ZKP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E-Non-Interactive-ZKP-NIZKP"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. 非交互式零知识证明 (Non-Interactive ZKP, NIZKP)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.</span> <span class="toc-text">零知识证明的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%9Azk-SNARKs-%E4%B8%8E-zk-STARKs-%E7%9A%84%E6%97%B6%E4%BB%A3"><span class="toc-number">4.</span> <span class="toc-text">第四章：从理论到实践：zk-SNARKs 与 zk-STARKs 的时代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%9A%84%E7%AE%97%E6%9C%AF%E5%8C%96%EF%BC%9A%E5%B0%86%E9%80%BB%E8%BE%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BB%A3%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">计算的算术化：将逻辑转化为代数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%89%BF%E8%AF%BA-Polynomial-Commitments"><span class="toc-number">4.2.</span> <span class="toc-text">多项式承诺 (Polynomial Commitments)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zk-SNARKs-%E7%AE%80%E6%B4%81%E7%9A%84%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AE%BA%E8%AF%81%E7%9F%A5%E8%AF%86%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E"><span class="toc-number">4.3.</span> <span class="toc-text">zk-SNARKs: 简洁的非交互式论证知识零知识证明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zk-STARKs-%E5%8F%AF%E6%89%A9%E5%B1%95%E3%80%81%E9%80%8F%E6%98%8E%E7%9A%84%E8%AE%BA%E8%AF%81%E7%9F%A5%E8%AF%86%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E"><span class="toc-number">4.4.</span> <span class="toc-text">zk-STARKs: 可扩展、透明的论证知识零知识证明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94%EF%BC%9ASNARKs-vs-STARKs"><span class="toc-number">4.5.</span> <span class="toc-text">总结与对比：SNARKs vs STARKs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%89%8D%E6%B2%BF%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">第五章：高级主题与前沿应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%AF%81%E6%98%8E%EF%BC%9A%E8%AF%81%E6%98%8E%E7%9A%84%E8%AF%81%E6%98%8E"><span class="toc-number">5.1.</span> <span class="toc-text">递归证明：证明的证明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E4%B8%8A%E5%BA%94%E7%94%A8%EF%BC%9Azk-Rollups-%E4%B8%8E-zkEVM"><span class="toc-number">5.2.</span> <span class="toc-text">链上应用：zk-Rollups 与 zkEVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-ZKML"><span class="toc-number">5.3.</span> <span class="toc-text">零知识机器学习 (ZKML)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E7%A7%81%E8%BA%AB%E4%BB%BD%E4%B8%8E%E5%8F%AF%E9%AA%8C%E8%AF%81%E5%87%AD%E8%AF%81"><span class="toc-number">5.4.</span> <span class="toc-text">隐私身份与可验证凭证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E5%85%B4%E5%BA%94%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">其他新兴应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%91%E6%88%98%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-number">5.6.</span> <span class="toc-text">挑战与未来展望</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%AE%9E%E8%B7%B5%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">第六章：实践工具与生态系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%B5%E8%B7%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%A1%86%E6%9E%B6"><span class="toc-number">6.1.</span> <span class="toc-text">1. 电路编程语言与框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ZKP-%E5%BC%80%E5%8F%91%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7"><span class="toc-number">6.2.</span> <span class="toc-text">2. ZKP 开发辅助工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%B1%82%E6%A1%86%E6%9E%B6%E4%B8%8E-SDKs"><span class="toc-number">6.3.</span> <span class="toc-text">3. 应用层框架与 SDKs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%91%E6%88%98%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="toc-number">6.4.</span> <span class="toc-text">4. 挑战与展望</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BF%A1%E3%80%81%E9%9A%90%E7%A7%81%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%95%B0%E5%AD%97%E6%9C%AA%E6%9D%A5"><span class="toc-number">7.</span> <span class="toc-text">结论：构建一个可信、隐私、可扩展的数字未来</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/hello-world/" title="Hello World">Hello World</a><time datetime="2025-07-23T10:05:21.111Z" title="发表于 2025-07-23 18:05:21">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="博弈论基础">博弈论基础</a><time datetime="2025-07-23T10:05:21.111Z" title="发表于 2025-07-23 18:05:21">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/2025-07-23-100250/" title="分形插值与函数逼近：驾驭平滑与复杂之间的艺术">分形插值与函数逼近：驾驭平滑与复杂之间的艺术</a><time datetime="2025-07-23T02:02:50.000Z" title="发表于 2025-07-23 10:02:50">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/2025-07-23-100126/" title="揭秘混沌：深度探索混沌系统的参数辨识艺术">揭秘混沌：深度探索混沌系统的参数辨识艺术</a><time datetime="2025-07-23T02:01:26.000Z" title="发表于 2025-07-23 10:01:26">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/2025-07-23-100010/" title="深入解析公钥基础设施（PKI）：数字世界的信任基石">深入解析公钥基础设施（PKI）：数字世界的信任基石</a><time datetime="2025-07-23T02:00:10.000Z" title="发表于 2025-07-23 10:00:10">2025-07-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By qmwneb946</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'qmwneb946/blog',
      'data-repo-id': 'R_kgDOPM6cWw',
      'data-category-id': 'DIC_kwDOPM6cW84CtEzo',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>