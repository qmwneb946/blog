<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算几何：赋能机器人路径规划的基石 | qmwneb946 的博客</title><meta name="author" content="qmwneb946"><meta name="copyright" content="qmwneb946"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="你好，各位技术爱好者和数学狂人！我是 qmwneb946，今天我们来聊一个既充满美感又极其实用的领域：计算几何在机器人路径规划中的应用。你是否曾好奇，自动驾驶汽车如何在复杂的城市环境中穿梭自如？工业机器臂如何精准无误地完成装配任务？服务机器人又如何在家庭环境中避开障碍物，将物品送到你手中？这一切的背后，都离不开“路径规划”这一核心技术，而计算几何，正是赋予路径规划“智慧之眼”的基石。 机器人路径规">
<meta property="og:type" content="article">
<meta property="og:title" content="计算几何：赋能机器人路径规划的基石">
<meta property="og:url" content="https://qmwneb946.dpdns.org/2025/07/19/2025-07-19-142619/index.html">
<meta property="og:site_name" content="qmwneb946 的博客">
<meta property="og:description" content="你好，各位技术爱好者和数学狂人！我是 qmwneb946，今天我们来聊一个既充满美感又极其实用的领域：计算几何在机器人路径规划中的应用。你是否曾好奇，自动驾驶汽车如何在复杂的城市环境中穿梭自如？工业机器臂如何精准无误地完成装配任务？服务机器人又如何在家庭环境中避开障碍物，将物品送到你手中？这一切的背后，都离不开“路径规划”这一核心技术，而计算几何，正是赋予路径规划“智慧之眼”的基石。 机器人路径规">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qmwneb946.dpdns.org/img/icon.png">
<meta property="article:published_time" content="2025-07-19T06:26:19.000Z">
<meta property="article:modified_time" content="2025-07-23T15:52:54.089Z">
<meta property="article:author" content="qmwneb946">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="计算几何在机器人路径规划的应用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qmwneb946.dpdns.org/img/icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算几何：赋能机器人路径规划的基石",
  "url": "https://qmwneb946.dpdns.org/2025/07/19/2025-07-19-142619/",
  "image": "https://qmwneb946.dpdns.org/img/icon.png",
  "datePublished": "2025-07-19T06:26:19.000Z",
  "dateModified": "2025-07-23T15:52:54.089Z",
  "author": [
    {
      "@type": "Person",
      "name": "qmwneb946",
      "url": "https://github.com/qmwneb946"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qmwneb946.dpdns.org/2025/07/19/2025-07-19-142619/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算几何：赋能机器人路径规划的基石',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2845632165165414" crossorigin="anonymous"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="qmwneb946 的博客" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">qmwneb946 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">计算几何：赋能机器人路径规划的基石</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">计算几何：赋能机器人路径规划的基石<a class="post-edit-link" href="https://github.com/qmwneb946/blog/edit/main/source/_posts/2025-07-19-142619.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-19T06:26:19.000Z" title="发表于 2025-07-19 14:26:19">2025-07-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-23T15:52:54.089Z" title="更新于 2025-07-23 23:52:54">2025-07-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>你好，各位技术爱好者和数学狂人！我是 qmwneb946，今天我们来聊一个既充满美感又极其实用的领域：计算几何在机器人路径规划中的应用。你是否曾好奇，自动驾驶汽车如何在复杂的城市环境中穿梭自如？工业机器臂如何精准无误地完成装配任务？服务机器人又如何在家庭环境中避开障碍物，将物品送到你手中？这一切的背后，都离不开“路径规划”这一核心技术，而计算几何，正是赋予路径规划“智慧之眼”的基石。</p>
<p>机器人路径规划，简单来说，就是为机器人在给定环境中找到一条从起点到终点的无碰撞路径。这听起来似乎不难，但当环境变得复杂，障碍物增多，机器人本身拥有复杂的几何形状，并且还需要考虑路径的优化（最短、最平滑、最安全），这个问题就变得异常挑战。计算几何，这门研究几何问题的算法和数据结构的学科，恰好提供了解决这些挑战的强大工具集。</p>
<p>在这篇文章中，我们将深入探讨计算几何如何从基础概念出发，一步步构建起机器人路径规划的理论框架，并最终落地为高效实用的算法。我们将触及以下几个关键方面：</p>
<ul>
<li>机器人路径规划的核心挑战与目标</li>
<li>计算几何的基本概念与几何表示方法</li>
<li>路径规划中的几何建模（环境与机器人）</li>
<li>经典的计算几何路径规划算法解析</li>
<li>计算几何在路径规划中的关键技术：碰撞检测、距离计算与路径优化</li>
<li>实际案例分析与未来的发展方向</li>
</ul>
<p>准备好了吗？让我们一同踏上这段充满几何智慧的旅程！</p>
<h2 id="机器人路径规划概述">机器人路径规划概述</h2>
<p>在深入计算几何的细节之前，我们首先需要对机器人路径规划有一个全面的认识。</p>
<h3 id="什么是路径规划？">什么是路径规划？</h3>
<p>机器人路径规划（Robot Path Planning）是机器人学中的一个核心研究领域，旨在寻找一条从起始状态（如位置、姿态）到目标状态的轨迹或路径，同时满足一系列约束条件。这些约束通常包括：</p>
<ol>
<li><strong>无碰撞（Collision-Free）</strong>：路径上的任何一点，机器人本体都不能与环境中的障碍物发生接触。</li>
<li><strong>可执行性（Feasibility）</strong>：路径必须符合机器人的动力学和运动学约束，例如最大速度、加速度、转弯半径等。</li>
<li><strong>优化（Optimality）</strong>：在满足前两项约束的前提下，路径通常还需要优化某个或多个性能指标，例如：
<ul>
<li><strong>最短路径</strong>：从起点到终点所需的路程最短。</li>
<li><strong>最平滑路径</strong>：避免剧烈转弯，便于机器人平稳执行。</li>
<li><strong>最安全路径</strong>：尽可能远离障碍物。</li>
<li><strong>最小能耗路径</strong>：减少机器人运行过程中的能量消耗。</li>
</ul>
</li>
</ol>
<p>路径规划不仅仅是平面上的“找路”，它可能涉及二维、三维甚至更高维度的构型空间（Configuration Space）中的搜索。</p>
<h3 id="路径规划的挑战">路径规划的挑战</h3>
<p>路径规划远非易事，面临诸多挑战：</p>
<ol>
<li><strong>环境复杂性</strong>：
<ul>
<li><strong>静态障碍物</strong>：墙壁、家具、地形等固定不变的物体。</li>
<li><strong>动态障碍物</strong>：移动的人、车辆、其他机器人等，其位置和速度随时间变化。</li>
<li><strong>不确定性</strong>：传感器噪声、环境模型的不准确性可能导致对障碍物的误判。</li>
</ul>
</li>
<li><strong>计算效率与实时性</strong>：在许多应用中（如自动驾驶），路径需要实时生成和更新，对算法的计算速度有极高要求。</li>
<li><strong>高维度状态空间</strong>：对于多关节机器人或多机器人系统，其构型空间维度很高，传统的搜索方法面临“维度灾难”。例如，一个六自由度（6-DOF）的机械臂，其构型空间就是六维的。</li>
<li><strong>路径平滑与可执行性</strong>：生成的路径可能仅仅是理论上的无碰撞路径，但由于不平滑或不满足动力学约束，机器人难以实际执行。</li>
<li><strong>未知环境探索</strong>：在完全未知的环境中，机器人需要边探索边规划。</li>
</ol>
<p>正是这些挑战，催生了对高效、鲁棒的几何算法的巨大需求，这正是计算几何大展身手的地方。</p>
<h2 id="计算几何基础">计算几何基础</h2>
<p>计算几何是路径规划的理论基石，它为我们理解和解决几何问题提供了数学工具和算法框架。</p>
<h3 id="什么是计算几何？">什么是计算几何？</h3>
<p>计算几何（Computational Geometry）是计算机科学的一个分支，它研究如何设计和分析解决几何问题的算法。这些问题通常涉及点、线、面、多边形等几何对象的处理。在机器人路径规划中，无论是表示机器人自身，还是描述环境中的障碍物，都需要用到几何对象。计算几何的目标是为这些几何对象之间的关系（如相交、包含、距离）提供高效的算法。</p>
<h3 id="核心几何概念与数据结构">核心几何概念与数据结构</h3>
<p>为了有效地进行路径规划，我们需要以一种计算机可理解和处理的方式来表示几何信息。</p>
<ol>
<li><strong>点（Point）</strong>：最基本的几何元素，通常表示为坐标对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 或坐标三元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y, z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>。在路径规划中，机器人位置、路径上的离散点都可以用点来表示。</li>
<li><strong>线段（Line Segment）</strong>：连接两个点的直线段。障碍物的边缘、机器人路径的一部分都可以看作线段。</li>
<li><strong>多边形（Polygon）</strong>：由一系列连接的首尾相接的线段（边）围成的闭合图形。多边形常用来表示二维环境中的障碍物或机器人的截面。
<ul>
<li><strong>凸多边形（Convex Polygon）</strong>：多边形内任意两点之间的线段完全位于多边形内部。凸多边形具有许多优良的计算性质，例如碰撞检测更简单。</li>
<li><strong>凹多边形（Concave Polygon）</strong>：不满足凸多边形性质的多边形。凹多边形可以通过分解成多个凸多边形来简化处理。</li>
</ul>
</li>
<li><strong>凸包（Convex Hull）</strong>：包含给定点集或几何对象集的最小凸多边形（在2D）或凸多面体（在3D）。在路径规划中，有时会将复杂形状的机器人或障碍物近似为其凸包，以简化碰撞检测。例如，两个物体之间的碰撞检测可以转换为它们凸包之间的碰撞检测，这通常更快。</li>
<li><strong>Voronoi图（Voronoi Diagram）</strong>：给定平面上的一组点（称为“生成元”），Voronoi图将平面划分为若干个区域，使得每个区域内的点都比其他任何区域的生成元更靠近该区域的生成元。在路径规划中，Voronoi图可以用来找到离所有障碍物最远的“最安全”路径。</li>
<li><strong>Delaunay三角剖分（Delaunay Triangulation）</strong>：是Voronoi图的对偶图，它将点集连接成三角形，使得任何一个三角形的外接圆内部不包含任何其他的点。Delaunay三角剖分可以用于网格生成、地形建模等。</li>
<li><strong>空间数据结构</strong>：为了高效地进行空间查询（如查找最近邻点、范围查询），计算几何发展出了多种数据结构：
<ul>
<li><strong>K-D树（K-Dimensional Tree）</strong>：一种用于组织 K 维空间中点的二叉树，常用于最近邻搜索。</li>
<li><strong>四叉树（Quadtree）/八叉树（Octree）</strong>：用于将二维/三维空间递归细分为象限/八分体的树状结构，有助于加速碰撞检测和范围查询。</li>
<li><strong>BSP树（Binary Space Partitioning Tree）</strong>：通过递归地用超平面（直线或平面）分割空间来组织几何对象。</li>
</ul>
</li>
</ol>
<h3 id="基本几何算法">基本几何算法</h3>
<p>理解了基本概念和数据结构后，我们来看看一些在路径规划中常用的基本几何算法。</p>
<ol>
<li><strong>点在多边形内测试（Point in Polygon Test）</strong>：判断一个点是在多边形内部、外部还是边界上。常用的算法包括：
<ul>
<li><strong>射线交叉法（Ray Casting Algorithm）</strong>：从待测点向任意方向发出一条射线，计算射线与多边形边的交点数量。如果交点数为奇数，则点在多边形内部；为偶数，则在外部。</li>
<li><strong>缠绕数法（Winding Number Algorithm）</strong>：计算多边形边界相对于待测点的“缠绕”次数。</li>
</ul>
</li>
<li><strong>线段相交测试（Line Segment Intersection Test）</strong>：判断两条线段是否相交。这是碰撞检测中的一个基本操作。例如，检查机器人路径上的一个线段是否与障碍物的边界线段相交。</li>
<li><strong>最近点对（Closest Pair of Points）</strong>：在一个点集中找到距离最近的两个点。在路径规划中，这可能用于优化路径，或者在稠密环境中判断机器人是否过于接近其他物体。</li>
<li><strong>凸包算法</strong>：构造给定点集的凸包。常用的算法包括Graham扫描法、Jarvis步进法（Gift Wrapping）。</li>
</ol>
<p>这些基本算法构成了更复杂路径规划算法的基石。</p>
<h2 id="路径规划中的几何表示">路径规划中的几何表示</h2>
<p>在路径规划中，有效表示机器人和环境的几何形状是至关重要的。不同的表示方法适用于不同的场景和算法。</p>
<h3 id="环境表示">环境表示</h3>
<p>环境表示（Environment Representation）是描述机器人所处空间中的障碍物和自由空间的方式。</p>
<ol>
<li><strong>栅格地图（Grid Maps / Occupancy Grids）</strong>：
<ul>
<li><strong>原理</strong>：将环境离散化为规则的二维或三维网格（或体素），每个网格单元被标记为“占据”（障碍物）或“自由”。</li>
<li><strong>优点</strong>：简单直观，易于处理，适用于A*等网格搜索算法，方便处理传感器数据（如激光雷达、深度相机）。</li>
<li><strong>缺点</strong>：分辨率受限，无法精确表示连续空间和复杂几何形状，可能存在“量化误差”。在处理狭窄通道时，可能需要非常高的分辨率，导致计算量剧增。</li>
<li><strong>应用</strong>：室内服务机器人、扫地机器人。</li>
</ul>
</li>
<li><strong>可见性图（Visibility Graphs）</strong>：
<ul>
<li><strong>原理</strong>：将环境中的障碍物顶点作为图的节点。如果两个顶点之间可以直线连接且不穿过任何障碍物，则在它们之间添加一条边。起点和终点也被添加到图中。</li>
<li><strong>优点</strong>：生成的路径是多边形环境中的最短路径（曼哈顿距离除外），且路径由直线段组成，易于机器人执行。</li>
<li><strong>缺点</strong>：对于具有大量顶点的复杂环境，构建可见性图的计算成本非常高（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2 \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 是顶点数）。不适用于动态环境。</li>
<li><strong>应用</strong>：静态、凸多边形障碍物环境。</li>
</ul>
</li>
<li><strong>Voronoi图（Voronoi Diagrams）</strong>：
<ul>
<li><strong>原理</strong>：在自由空间中生成一条路径，该路径上的所有点到最近障碍物的距离都相等，即这条路径是“最安全”的，因为它尽可能远离所有障碍物。</li>
<li><strong>优点</strong>：生成的路径通常是平滑的，且提供了最大的安全裕度。</li>
<li><strong>缺点</strong>：路径可能不是最短的；构建过程相对复杂；对环境变化敏感。</li>
<li><strong>应用</strong>：需要高安全性的避障任务。</li>
</ul>
</li>
<li><strong>细胞分解（Cell Decomposition）</strong>：
<ul>
<li><strong>原理</strong>：将机器人的自由工作空间分解成一组简单的、非重叠的、连通的单元（或“细胞”），如矩形、梯形或三角形。然后构建一个连通图，其中节点是这些细胞的中心点或边缘中点，边表示相邻细胞之间的可通行性。路径规划问题转化为在细胞连通图上的搜索。</li>
<li><strong>优点</strong>：可以将连续空间问题转化为离散图搜索问题，易于实现。可以处理凹形障碍物。</li>
<li><strong>缺点</strong>：分解过程可能复杂且耗时，生成的路径可能不是最优的。</li>
<li><strong>子类型</strong>：
<ul>
<li><strong>精确细胞分解</strong>：如梯形分解，将空间分解为梯形。</li>
<li><strong>近似细胞分解</strong>：如四叉树/八叉树分解，将空间递归分解。</li>
</ul>
</li>
</ul>
</li>
<li><strong>构型空间（Configuration Space, C-Space）</strong>：
<ul>
<li><strong>原理</strong>：这是路径规划中最核心也是最具数学美感的概念之一。它将机器人的所有可能位置和姿态组合（即机器人的“构型”）构成一个多维空间。在这个空间中，<strong>机器人被抽象为一个点</strong>。相应的，环境中的每个障碍物在C-空间中都会“膨胀”为一个更大的、形状更复杂的C-障碍物。因此，机器人本体与物理障碍物的碰撞问题，在C-空间中就简化为<strong>C-空间的点机器人与C-障碍物之间的碰撞问题</strong>。</li>
<li><strong>构建C-空间障碍物</strong>：设机器人为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，障碍物为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。机器人的构型为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>。机器人在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 构型下占据的空间表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 相交，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 是一个碰撞构型。所有碰撞构型构成的集合就是C-障碍物 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>B</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">CB_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。通常，如果机器人 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 可以表示为一个凸多边形，障碍物 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 也是凸多边形，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>B</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">CB_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可以通过闵可夫斯基和（Minkowski Sum） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⊖</mo><mi>A</mi><mo>=</mo><mo stretchy="false">{</mo><mi>b</mi><mo>−</mo><mi>a</mi><mi mathvariant="normal">∣</mi><mi>b</mi><mo>∈</mo><mi>B</mi><mo separator="true">,</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">B \ominus A = \{b-a | b \in B, a \in A\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊖</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">}</span></span></span></span> 来计算（这里是差集，因为我们通常考虑机器人 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 绕原点旋转并平移到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>）。</li>
<li><strong>优点</strong>：将复杂几何形状的机器人简化为点，极大地简化了路径规划问题。</li>
<li><strong>缺点</strong>：C-空间维度高，且C-障碍物形状通常非常复杂，难以显式计算和表示，尤其是在高维空间中。这导致了许多路径规划算法（如PRM、RRT）在C-空间中进行采样和隐式碰撞检测。</li>
</ul>
</li>
</ol>
<h3 id="机器人表示">机器人表示</h3>
<p>机器人本身的几何形状也需要被准确表示，以便进行碰撞检测。</p>
<ol>
<li><strong>点机器人（Point Robot）</strong>：最简单的表示，将机器人视为一个没有体积的点。这通常是在C-空间中进行规划时使用的抽象。</li>
<li><strong>圆形/球形机器人（Circular/Spherical Robot）</strong>：将机器人近似为一个圆形（2D）或球形（3D）。这种表示非常适合简单的移动机器人，碰撞检测可以简化为圆心到障碍物边缘的距离与半径的比较。</li>
<li><strong>多边形/多面体机器人（Polygonal/Polyhedral Robot）</strong>：更精确的表示，适用于具有复杂形状的机器人。对于凹形机器人，通常会将其分解为多个凸多边形或凸多面体来处理，或者用包围盒（Bounding Box）等简单几何体进行近似。</li>
<li><strong>关节机器人（Articulated Robot）</strong>：对于机械臂等由多个连杆和关节组成的机器人，通常将每个连杆视为一个单独的几何体（如长方体、圆柱体或多面体），并考虑它们在运动过程中可能发生的自碰撞。</li>
</ol>
<h2 id="典型的计算几何路径规划算法">典型的计算几何路径规划算法</h2>
<p>现在，让我们看看计算几何是如何融入具体的路径规划算法的。</p>
<h3 id="基于图搜索的算法与几何结合">基于图搜索的算法与几何结合</h3>
<p>许多经典的图搜索算法（如Dijkstra、A*）在离散的栅格地图或可见性图上表现出色。</p>
<ol>
<li><strong>A*算法与可见性图</strong>：
<ul>
<li><strong>原理</strong>：首先构建环境的可见性图，将起点、终点和所有障碍物顶点作为图的节点。然后，在可见性图上运行A<em>算法。A</em>算法使用启发式函数引导搜索，以找到从起点到终点的最短路径。启发式函数通常是欧几里得距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>g</mi><mi>o</mi><mi>a</mi><mi>l</mi></mrow></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>n</mi></msub><mo>−</mo><msub><mi>y</mi><mrow><mi>g</mi><mi>o</mi><mi>a</mi><mi>l</mi></mrow></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">h(n) = \sqrt{(x_n - x_{goal})^2 + (y_n - y_{goal})^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.3231em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9169em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.8769em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3231em;"><span></span></span></span></span></span></span></span></span>。</li>
<li><strong>几何作用</strong>：可见性图的构建是纯粹的计算几何问题（线段相交测试、点在多边形内测试等）。A*算法在几何图上进行搜索。</li>
<li><strong>局限性</strong>：构建可见性图的计算复杂度高，不适用于障碍物数量庞大或动态变化的场景。</li>
</ul>
</li>
</ol>
<h3 id="采样式规划算法">采样式规划算法</h3>
<p>针对高维C-空间的“维度灾难”问题，采样式规划算法应运而生，它们在C-空间中随机采样点，并通过几何检测来构建连通图或树。</p>
<ol>
<li><strong>概率路线图（Probabilistic Roadmaps, PRM）</strong>：
<ul>
<li><strong>原理</strong>：
<ol>
<li><strong>采样阶段</strong>：在C-空间中随机采样大量构型点，并丢弃那些位于C-障碍物内的碰撞构型。</li>
<li><strong>连接阶段</strong>：对于每个有效的采样点，尝试将其与附近（例如，通过K-D树找到最近邻）的其他有效采样点连接起来，形成一条C-空间路径（通常是直线段）。如果连接路径在整个过程中不与任何C-障碍物发生碰撞，则在图上添加一条边。</li>
<li><strong>查询阶段</strong>：当需要规划路径时，将起点和终点添加到图中，然后使用A*或Dijkstra等图搜索算法在构建好的路线图上找到路径。</li>
</ol>
</li>
<li><strong>几何作用</strong>：
<ul>
<li><strong>碰撞检测</strong>：连接阶段的核心。检测机器人从一个构型到另一个构型的直线路径是否无碰撞。这涉及到机器人几何形状与障碍物几何形状的精确碰撞检测。</li>
<li><strong>最近邻搜索</strong>：使用K-D树等空间数据结构高效查找附近采样点。</li>
</ul>
</li>
<li><strong>优点</strong>：适用于高维空间，无需显式构建C-障碍物，只需进行碰撞检测。</li>
<li><strong>缺点</strong>：无法保证找到路径（完备性），尤其是在狭窄通道中，可能需要大量的采样点。</li>
</ul>
</li>
<li><em><em>快速探索随机树（Rapidly-exploring Random Trees, RRT）及其变种（RRT</em>）</em>*：
<ul>
<li><strong>原理</strong>：
<ol>
<li>从起点构型开始，以目标构型为引导，向随机采样的构型点方向“生长”一棵树。</li>
<li>在每次迭代中，从树中选取一个节点（通常是离随机采样点最近的节点），然后从该节点向随机采样点方向以固定步长生长一个新的节点。</li>
<li>同样，新生成的路径段必须是无碰撞的。</li>
<li>RRT*在RRT的基础上增加了优化机制，通过“重新布线”（rewiring）来保证渐近最优性。</li>
</ol>
</li>
<li><strong>几何作用</strong>：
<ul>
<li><strong>碰撞检测</strong>：每一步的生长都需要进行碰撞检测。</li>
<li><strong>最近邻搜索</strong>：快速找到树中离随机采样点最近的节点。</li>
</ul>
</li>
<li><strong>优点</strong>：单次查询效率高，适用于高维空间和动态环境。RRT*能够找到渐近最优路径。</li>
<li><strong>缺点</strong>：生成的路径可能不平滑，且随机性意味着每次结果可能不同。</li>
</ul>
</li>
</ol>
<h3 id="基于细胞分解的算法">基于细胞分解的算法</h3>
<ol>
<li><strong>梯形分解（Trapezoidal Decomposition）</strong>：
<ul>
<li><strong>原理</strong>：将二维自由空间分解为一系列梯形。从每个障碍物顶点向上和向下引射线直到遇到另一个障碍物或环境边界，从而将空间分割成梯形和三角形。然后构建一个连通图，节点代表这些梯形，边连接相邻的梯形。</li>
<li><strong>几何作用</strong>：射线交叉测试、寻找最近的障碍物边界等都是几何操作。</li>
<li><strong>优点</strong>：能够处理凹形障碍物，生成的分解是精确的。</li>
<li><strong>缺点</strong>：对于复杂的环境，梯形数量可能非常庞大，增加了图搜索的复杂性。</li>
</ul>
</li>
</ol>
<h2 id="计算几何在路径规划中的关键技术点">计算几何在路径规划中的关键技术点</h2>
<p>除了上述算法，计算几何还提供了支撑这些算法运行的关键技术。</p>
<h3 id="碰撞检测（Collision-Detection）">碰撞检测（Collision Detection）</h3>
<p>碰撞检测是路径规划中最频繁执行且计算量最大的操作之一。它决定了机器人在当前构型是否与障碍物相交，或者两个物体是否会相互碰撞。</p>
<ol>
<li><strong>包围盒层次结构（Bounding Volume Hierarchies, BVH）</strong>：
<ul>
<li><strong>原理</strong>：对于复杂的几何模型，直接进行精确碰撞检测开销巨大。BVH通过用简单的几何体（如轴对齐包围盒AABB、有向包围盒OBB、球体）来包裹复杂的物体。然后，先检测这些简单的包围盒是否相交。如果包围盒不相交，则其内部的复杂物体肯定也不相交，从而快速排除大量非碰撞情况。如果包围盒相交，则递归地检测下一层更小的包围盒，直到叶子节点进行精确检测。</li>
<li><strong>类型</strong>：
<ul>
<li><strong>AABB (Axis-Aligned Bounding Box)</strong>：轴对齐包围盒，简单但紧密性不佳。</li>
<li><strong>OBB (Oriented Bounding Box)</strong>：有向包围盒，可以更好地贴合物体方向，但检测更复杂。</li>
<li><strong>Sphere (球体)</strong>：最简单，但紧密性最差。</li>
<li><strong>Capsule (胶囊体)</strong>：对于长条形物体（如机械臂连杆）非常有效。</li>
</ul>
</li>
<li><strong>优点</strong>：显著提高碰撞检测效率，尤其适用于复杂模型和大量物体。</li>
</ul>
</li>
<li><strong>GJK算法与EPA算法</strong>：
<ul>
<li><strong>GJK (Gilbert-Johnson-Keerthi) 算法</strong>：一种用于判断两个凸多面体是否相交的算法。它的核心思想是利用闵可夫斯基差集（Minkowski Difference）的概念，判断闵可夫斯基差集是否包含原点。</li>
<li><strong>EPA (Expanding Polytope Algorithm) 算法</strong>：在GJK算法判断出两个物体相交后，EPA可以用于计算它们的最小穿透深度和法向量，这对于碰撞响应（如在物理模拟中）非常重要。</li>
<li><strong>优点</strong>：非常高效且通用，可以处理任意凸多面体，且在高维空间中也适用。</li>
</ul>
</li>
<li><strong>分离轴定理（Separating Axis Theorem, SAT）</strong>：
<ul>
<li><strong>原理</strong>：如果两个凸多边形（或多面体）不相交，那么一定存在一条直线（或平面），使得两个多边形（或多面体）在该直线（或平面）上的投影不重叠。反之，如果能找到这样的轴，则两者不相交。</li>
<li><strong>优点</strong>：实现相对简单，对于凸多边形或多面体非常有效。</li>
<li><strong>缺点</strong>：只能用于凸体。</li>
</ul>
</li>
</ol>
<p>以下是一个简单的2D线段相交检测的Python代码示例，它在许多碰撞检测中都是基础操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个简单的2D线段相交检测函数</span></span><br><span class="line"><span class="comment"># 作者：qmwneb946</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">orientation</span>(<span class="params">p, q, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算三个点p, q, r的“方向”：</span></span><br><span class="line"><span class="string">    0 --&gt; 共线</span></span><br><span class="line"><span class="string">    1 --&gt; 顺时针</span></span><br><span class="line"><span class="string">    2 --&gt; 逆时针</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    val = (q[<span class="number">1</span>] - p[<span class="number">1</span>]) * (r[<span class="number">0</span>] - q[<span class="number">0</span>]) - \</span><br><span class="line">          (q[<span class="number">0</span>] - p[<span class="number">0</span>]) * (r[<span class="number">1</span>] - q[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> val == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 共线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> val &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">2</span> <span class="comment"># 顺时针或逆时针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_segment</span>(<span class="params">p, q, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断点q是否在线段pr上（假设p,q,r共线）。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (q[<span class="number">0</span>] &lt;= <span class="built_in">max</span>(p[<span class="number">0</span>], r[<span class="number">0</span>]) <span class="keyword">and</span> q[<span class="number">0</span>] &gt;= <span class="built_in">min</span>(p[<span class="number">0</span>], r[<span class="number">0</span>]) <span class="keyword">and</span></span><br><span class="line">            q[<span class="number">1</span>] &lt;= <span class="built_in">max</span>(p[<span class="number">1</span>], r[<span class="number">1</span>]) <span class="keyword">and</span> q[<span class="number">1</span>] &gt;= <span class="built_in">min</span>(p[<span class="number">1</span>], r[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_intersect</span>(<span class="params">p1, q1, p2, q2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断线段p1q1和p2q2是否相交。</span></span><br><span class="line"><span class="string">    p1, q1 是第一条线段的端点。</span></span><br><span class="line"><span class="string">    p2, q2 是第二条线段的端点。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 找到四种方向</span></span><br><span class="line">    o1 = orientation(p1, q1, p2)</span><br><span class="line">    o2 = orientation(p1, q1, q2)</span><br><span class="line">    o3 = orientation(p2, q2, p1)</span><br><span class="line">    o4 = orientation(p2, q2, q1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一般情况：四个方向都非零，且方向不同</span></span><br><span class="line">    <span class="keyword">if</span> o1 != <span class="number">0</span> <span class="keyword">and</span> o2 != <span class="number">0</span> <span class="keyword">and</span> o3 != <span class="number">0</span> <span class="keyword">and</span> o4 != <span class="number">0</span> <span class="keyword">and</span> \</span><br><span class="line">       o1 != o2 <span class="keyword">and</span> o3 != o4:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 特殊情况（共线且重叠）</span></span><br><span class="line">    <span class="comment"># p1, q1, p2 共线且p2在线段p1q1上</span></span><br><span class="line">    <span class="keyword">if</span> o1 == <span class="number">0</span> <span class="keyword">and</span> on_segment(p1, p2, q1): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># p1, q1, q2 共线且q2在线段p1q1上</span></span><br><span class="line">    <span class="keyword">if</span> o2 == <span class="number">0</span> <span class="keyword">and</span> on_segment(p1, q2, q1): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># p2, q2, p1 共线且p1在线段p2q2上</span></span><br><span class="line">    <span class="keyword">if</span> o3 == <span class="number">0</span> <span class="keyword">and</span> on_segment(p2, p1, q2): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># p2, q2, q1 共线且q1在线段p2q2上</span></span><br><span class="line">    <span class="keyword">if</span> o4 == <span class="number">0</span> <span class="keyword">and</span> on_segment(p2, q1, q2): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 不满足上述任何情况，不相交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line"><span class="comment"># 线段1: (0,0) - (10,10)</span></span><br><span class="line"><span class="comment"># 线段2: (0,10) - (10,0)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;线段 (0,0)-(10,10) 和 (0,10)-(10,0) 是否相交? <span class="subst">&#123;do_intersect((<span class="number">0</span>,<span class="number">0</span>), (<span class="number">10</span>,<span class="number">10</span>), (<span class="number">0</span>,<span class="number">10</span>), (<span class="number">10</span>,<span class="number">0</span>))&#125;</span>&quot;</span>) <span class="comment"># 应该为 True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线段1: (0,0) - (10,0)</span></span><br><span class="line"><span class="comment"># 线段2: (11,0) - (20,0) (平行不重叠)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;线段 (0,0)-(10,0) 和 (11,0)-(20,0) 是否相交? <span class="subst">&#123;do_intersect((<span class="number">0</span>,<span class="number">0</span>), (<span class="number">10</span>,<span class="number">0</span>), (<span class="number">11</span>,<span class="number">0</span>), (<span class="number">20</span>,<span class="number">0</span>))&#125;</span>&quot;</span>) <span class="comment"># 应该为 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线段1: (0,0) - (10,0)</span></span><br><span class="line"><span class="comment"># 线段2: (5,0) - (15,0) (共线且重叠)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;线段 (0,0)-(10,0) 和 (5,0)-(15,0) 是否相交? <span class="subst">&#123;do_intersect((<span class="number">0</span>,<span class="number">0</span>), (<span class="number">10</span>,<span class="number">0</span>), (<span class="number">5</span>,<span class="number">0</span>), (<span class="number">15</span>,<span class="number">0</span>))&#125;</span>&quot;</span>) <span class="comment"># 应该为 True</span></span><br></pre></td></tr></table></figure>
<h3 id="距离计算与最近邻搜索">距离计算与最近邻搜索</h3>
<p>距离计算是评估路径质量和避免近距离碰撞的关键。最近邻搜索则在采样式规划算法中频繁使用，用于找到离新采样点最近的树节点或路线图节点。</p>
<ol>
<li><strong>欧几里得距离</strong>：最常见的距离度量，在二维空间中为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.305em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.895em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305em;"><span></span></span></span></span></span></span></span></span>，三维空间中类似。</li>
<li><strong>曼哈顿距离（Manhattan Distance / Taxicab Distance）</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">d = |x_2-x_1| + |y_2-y_1|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，常用于栅格地图。</li>
<li><strong>点到线段/多边形/曲面的距离</strong>：计算机器人某一点到障碍物几何体的最短距离，用于评估安全裕度。</li>
<li><strong>空间数据结构的应用</strong>：K-D树、球树、八叉树等可以显著加速大规模点集或物体集中的最近邻查询。</li>
</ol>
<h3 id="几何变换与坐标系">几何变换与坐标系</h3>
<p>机器人通常在不同的坐标系下工作（如机器人自身坐标系、世界坐标系、传感器坐标系）。在路径规划中，需要进行频繁的几何变换（平移、旋转、缩放），以将机器人和障碍物从各自的局部坐标系转换到统一的世界坐标系，以便进行碰撞检测和距离计算。</p>
<ul>
<li><strong>平移矩阵</strong>：将点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y, z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 移动到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>y</mi><mo>+</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><mi>z</mi><mo>+</mo><msub><mi>t</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x+t_x, y+t_y, z+t_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li><strong>旋转矩阵</strong>：根据欧拉角或四元数绕特定轴旋转。</li>
<li><strong>齐次坐标</strong>：将平移、旋转和缩放统一表示为矩阵乘法，方便链式变换。例如，一个点的齐次坐标表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y, z, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<h3 id="路径平滑与优化">路径平滑与优化</h3>
<p>原始生成的路径（如RRT或A*路径）可能由一系列直线段组成，转角尖锐，不适合机器人直接执行。计算几何提供了多种方法来平滑和优化这些路径。</p>
<ol>
<li><strong>曲线拟合</strong>：
<ul>
<li><strong>贝塞尔曲线（Bézier Curves）</strong>：由控制点定义的多项式曲线。改变控制点可以平滑地调整曲线形状。常用于生成平滑的机器人轨迹。</li>
<li><strong>B样条曲线（B-spline Curves）</strong>：比贝塞尔曲线更灵活，具有局部控制性（改变一个控制点只影响曲线的局部区域），且能够生成任意阶数的曲线。在机器人轨迹规划中非常流行。</li>
<li><strong>样条插值</strong>：通过给定的一系列路径点，插值生成平滑的曲线。</li>
</ul>
</li>
<li><strong>路径缩短与清理</strong>：移除路径中冗余的中间点，或者将路径中的多个直线段合并为更长的直线段，同时确保无碰撞。</li>
<li><strong>梯度下降/优化方法</strong>：将路径规划视为一个优化问题，通过迭代调整路径点来最小化成本函数（如路径长度、平滑度、远离障碍物的距离），同时保持无碰撞约束。这通常需要计算路径对环境的“梯度”，这本身就涉及到几何距离计算。</li>
</ol>
<h2 id="案例分析与应用实例">案例分析与应用实例</h2>
<p>计算几何在机器人路径规划中的应用无处不在，以下是一些典型案例：</p>
<ol>
<li><strong>无人驾驶汽车</strong>：
<ul>
<li><strong>停车场泊车</strong>：利用车辆的几何模型和停车位的几何信息，规划出多段圆弧和直线段组成的无碰撞路径。</li>
<li><strong>复杂交通流避障</strong>：实时检测其他车辆和行人的几何形状及运动趋势，预测潜在碰撞，并规划规避路径。构型空间的概念在这里变得复杂，因为需要考虑车辆的多个自由度（位置、朝向）以及动态障碍物。</li>
<li><strong>车道保持与轨迹跟踪</strong>：虽然主要是控制问题，但其基准轨迹的生成和优化也离不开几何曲线。</li>
</ul>
</li>
<li><strong>工业机器人</strong>：
<ul>
<li><strong>抓取与装配</strong>：规划机械臂末端执行器从起始位置到目标抓取/放置位置的无碰撞路径。需要考虑机械臂的每个连杆与工件、夹具、环境之间的碰撞。碰撞检测、构型空间搜索是核心。</li>
<li><strong>焊接、喷涂等连续轨迹任务</strong>：生成平滑且精确的轨迹，确保机器人工具沿着预定的几何路径移动。通常使用B样条曲线或其他样条插值方法。</li>
</ul>
</li>
<li><strong>服务机器人</strong>：
<ul>
<li><strong>室内导航与避障</strong>：扫地机器人、送餐机器人等需要在家庭或办公环境中自主导航。栅格地图、Voronoi图或PRM/RRT算法常被用于避开家具、墙壁和动态行人。</li>
<li><strong>跟随与交互</strong>：机器人需要识别并跟踪人的几何形状，并保持安全距离。</li>
</ul>
</li>
<li><strong>无人机（UAV）</strong>：
<ul>
<li><strong>三维空间路径规划</strong>：无人机需要在三维空间中避开建筑物、树木和地形。三维栅格地图、八叉树以及三维PRM/RRT是常用的方法。碰撞检测需要处理三维多面体。</li>
<li><strong>避开禁飞区</strong>：将禁飞区表示为三维几何体，规划路径时避免进入这些区域。</li>
</ul>
</li>
</ol>
<h2 id="挑战与未来方向">挑战与未来方向</h2>
<p>尽管计算几何在机器人路径规划中取得了显著进展，但仍面临诸多挑战和广阔的未来发展空间。</p>
<ol>
<li><strong>动态与不确定环境下的实时规划</strong>：
<ul>
<li>如何高效地预测动态障碍物的运动轨迹并实时更新C-障碍物？</li>
<li>如何在传感器数据不确定性或环境模型不精确的情况下进行鲁棒规划？这需要将几何算法与概率论、机器学习方法结合。</li>
</ul>
</li>
<li><strong>高维构型空间与复杂系统</strong>：
<ul>
<li>多关节机器人（如人形机器人）或多机器人系统具有非常高的自由度，导致C-空间维度极高，显式规划几乎不可能。如何设计更高效的采样、搜索和优化算法？</li>
<li>物理限制（如动力学约束、力矩限制）如何更紧密地融入几何规划？</li>
</ul>
</li>
<li><strong>计算效率与硬件加速</strong>：
<ul>
<li>对于大型复杂环境和实时应用，如何进一步优化几何算法，利用GPU等并行计算能力加速碰撞检测和空间查询？</li>
</ul>
</li>
<li><strong>学习与几何的深度融合</strong>：
<ul>
<li>如何将深度学习、强化学习等AI技术与计算几何方法相结合？例如，利用神经网络学习C-障碍物的复杂边界，或预测最优的采样策略。</li>
<li>通过学习从大量规划经验中提取几何特征和规划策略。</li>
</ul>
</li>
<li><strong>复杂几何与拓扑</strong>：
<ul>
<li>如何高效处理非流形、有孔洞或自相交的复杂几何模型？</li>
<li>拓扑学理论如何为路径规划提供更深层次的见解，例如在复杂三维环境中寻找同伦等价的路径族。</li>
</ul>
</li>
</ol>
<h2 id="结论">结论</h2>
<p>计算几何，作为数学和计算机科学的交叉学科，无疑是机器人路径规划领域不可或缺的基石。从基本的点线面操作，到复杂的构型空间建模；从高效的碰撞检测，到智能的采样式规划；再到路径的平滑优化，计算几何的智慧贯穿了路径规划的每一个环节。它赋予了机器人“看”懂环境的能力，并“思考”出如何安全、高效地从A点到达B点的策略。</p>
<p>随着机器人技术向更复杂、更智能、更自主的方向发展，计算几何的重要性只会与日俱增。未来的路径规划将不仅仅是找到一条路径，更是要在动态、不确定、高维度的现实世界中，实现机器人与环境的无缝、智能交互。我相信，随着计算几何理论和算法的不断进步，以及与人工智能、大数据等前沿技术的深度融合，机器人将能够以我们今天难以想象的方式，在各种复杂环境中自由穿梭，真正步入我们的生活。</p>
<p>希望这篇深入的博文能让你对计算几何在机器人路径规划中的应用有一个全面而深刻的理解。如果你有任何疑问或想分享自己的见解，欢迎在评论区与我交流。我是 qmwneb946，下次再见！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/qmwneb946">qmwneb946</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qmwneb946.dpdns.org/2025/07/19/2025-07-19-142619/">https://qmwneb946.dpdns.org/2025/07/19/2025-07-19-142619/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a> 许可协议。转载请注明来源 <a href="https://qmwneb946.dpdns.org" target="_blank">qmwneb946 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E5%BA%94%E7%94%A8/">计算几何在机器人路径规划的应用</a></div><div class="post-share"><div class="social-share" data-image="/img/icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/19/2025-07-19-142742/" title="生物相容性高分子材料：从分子设计到生命应用的前沿探索"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">生物相容性高分子材料：从分子设计到生命应用的前沿探索</div></div><div class="info-2"><div class="info-item-1"> 引言：生命与材料的邂逅 在当今科技飞速发展的时代，人类对健康和生命质量的追求从未停歇。其中，材料科学与生命科学的交叉融合，催生了一个充满无限可能的研究领域——生物医学材料。而在这片广阔的沃土上，生物相容性高分子材料无疑是璀璨的明星，它们以独特的柔韧性、可设计性以及与生物体的和谐共存能力，正在悄然改变着医疗保健的未来。 想象一下，一枚能完美替代受损骨骼的人工关节，一片能促进伤口愈合的智能敷料，一种能精准靶向病灶并缓释药物的纳米载体，乃至未来可能实现的人工器官……这些看似科幻的场景，都离不开生物相容性高分子材料的贡献。它们是连接无机世界与有机生命的桥梁，是工程学原理与生物学复杂性完美结合的典范。 作为一名热衷于探索技术与数学奥秘的博主（qmwneb946），我深知，任何一项前沿技术的突破，都离不开对其底层原理的深刻理解。生物相容性高分子材料并非仅仅是“无毒”那么简单，其背后蕴含着精妙的分子设计、复杂的界面相互作用、以及对生物体内微环境的精准响应。今天，我将带领大家深入这场跨学科的盛宴，从分子层面的结构奥秘，到宏观层面的功能实现，再到它们在生命科学中的广泛应用和未来的无限可能，一同揭...</div></div></div></a><a class="pagination-related" href="/2025/07/19/2025-07-19-142515/" title="数字孪生城市：从概念到实践的深度剖析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数字孪生城市：从概念到实践的深度剖析</div></div><div class="info-2"><div class="info-item-1"> 作为一名深耕技术与数学领域的博主，我 qmwneb946 始终对那些能够将前沿科技与人类社会发展紧密结合的创新概念充满好奇。在当今数字化浪潮的巅峰，一个引人注目的概念正逐渐从科幻走向现实，它就是——数字孪生城市（Digital Twin City）。这不仅仅是一个时髦词汇，更是一种革新城市规划、建设、运营和管理模式的强大范式。它承诺为我们提供一个虚拟而精确的城市副本，使我们能够以前所未有的洞察力来理解、预测并优化现实世界的城市系统。 今天，我们将一起踏上这场深度探索之旅，剖析数字孪生城市的核心概念、支撑技术、典型架构、实践应用，以及其面临的挑战与无限的未来展望。让我们共同揭开这座“孪生之城”的神秘面纱。 1. 引言：数字化浪潮下的城市愿景 在人类文明史上，城市一直是经济、文化、社会活动的核心载体。然而，随着人口的快速增长、全球气候变化、资源消耗加剧以及日益复杂的城市运行机制，传统粗放式的城市管理模式已难以应对层出不穷的挑战：交通拥堵、环境污染、能源短缺、灾害频发、公共服务效率低下等等。为了应对这些挑战，**智慧城市（Smart City）**的概念应运而生，强调利用信息通信技术...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/18/2025-07-18-082448/" title="数据挖掘在金融风控的应用：从算法到实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">数据挖掘在金融风控的应用：从算法到实践</div></div><div class="info-2"><div class="info-item-1">大家好，我是你们的技术博主，今天我们来深入探讨一个与我们日常生活息息相关，却又充满技术挑战的领域：金融风控。在这个领域中，数据挖掘技术发挥着越来越重要的作用，它帮助金融机构有效识别和管理风险，保障金融体系的稳定运行。本文将从多个角度深入探讨数据挖掘在金融风控中的应用，并结合实际案例进行分析。 数据挖掘在金融风控中的关键作用 金融风控的目标是识别、评估和控制各种金融风险，例如信用风险、欺诈风险、操作风险等。传统的风控方法往往依赖于人工审核和简单的统计模型，效率低、准确率不高。而数据挖掘技术的出现，为金融风控带来了革命性的变革。它能够从海量数据中提取有价值的信息，建立更精确的风险模型，从而提高风控效率和准确性。 具体来说，数据挖掘在金融风控中主要发挥以下作用： 欺诈检测 欺诈行为日益猖獗，给金融机构造成巨大的经济损失。数据挖掘技术，特别是异常检测算法，能够有效识别出可疑交易行为。例如，基于机器学习的异常检测模型可以学习正常交易的模式，然后识别偏离该模式的异常交易，从而有效识别潜在的欺诈行为。常用的算法包括：  孤立森林 (Isolation Forest): 通过随机分割数据来隔离异...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082509/" title="虚拟现实技术的沉浸式体验：从感知到认知"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">虚拟现实技术的沉浸式体验：从感知到认知</div></div><div class="info-2"><div class="info-item-1">虚拟现实（VR）技术不再是科幻小说中的幻想，它已经逐渐融入我们的生活，并正在深刻地改变着我们与世界互动的方式。本文将深入探讨VR技术的沉浸式体验，从技术原理到感知机制，再到其潜在的应用和未来发展方向，为技术爱好者提供一个全面的视角。 沉浸式体验的奥秘：技术层面 VR技术能够创造出令人信服的沉浸式体验，这依赖于多项关键技术的协同作用。 显示技术与图像渲染 高质量的图像渲染是VR体验的关键。高分辨率、高刷新率的显示器能够有效减少画面延迟和模糊感，提升视觉舒适度。目前主流的VR头显大多采用OLED或LCD屏幕，并通过透镜系统将图像投射到用户的视网膜上，模拟真实世界的视觉体验。  为了实现更广阔的视野（FOV），厂商们也在不断改进透镜设计和显示面板技术。 空间音频技术 除了视觉，听觉在构建沉浸式环境中也扮演着至关重要的角色。空间音频技术通过模拟声音在三维空间中的传播，让用户能够准确感知声音的方位和距离，增强临场感。例如，头部追踪技术配合精密的算法，可以根据用户头部姿态实时调整声音的输出，使声音效果更加逼真。 追踪技术与交互方式 精确的追踪技术是VR体验流畅的关键。目前常用的追踪技术包括：...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082730/" title="有机合成中的手性催化技术：构建分子世界的精巧艺术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">有机合成中的手性催化技术：构建分子世界的精巧艺术</div></div><div class="info-2"><div class="info-item-1">有机合成，这门将简单的化学物质转化为复杂分子的艺术，正因手性分子的存在而变得更加精妙和挑战性。手性分子如同左右手一样，结构互为镜像，但性质却可能大相径庭。在药物研发、材料科学等领域，获得特定手性的分子至关重要，而手性催化技术正是实现这一目标的关键。本文将深入探讨有机合成中的手性催化技术，揭示其背后的原理和应用。 手性与手性催化：从镜像到精准控制 手性，源于希腊语“cheir”（手），指的是分子不能与其镜像重合的特性。这种结构差异导致手性分子具有不同的物理性质和生物活性。例如，一种药物的左旋体可能具有疗效，而其右旋体则可能无效甚至有害。因此，精准控制手性合成至关重要。 手性催化技术利用手性催化剂来控制反应的立体选择性，即优先生成特定手性的产物。催化剂本身是手性的，它通过与反应物形成短暂的超分子复合物，影响反应路径，从而引导反应朝特定立体异构体方向进行。这就好比一个熟练的工匠，用巧妙的手法引导反应物“组装”成预期的分子结构。 手性催化剂的类型及作用机制 目前，广泛应用的手性催化剂主要包括： 过渡金属配合物催化剂 这类催化剂通常含有手性配体与过渡金属中心（如铑、钌、钯等）结合而成。配体...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082852/" title="光谱分析技术在环境监测的应用：从原理到实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">光谱分析技术在环境监测的应用：从原理到实践</div></div><div class="info-2"><div class="info-item-1">大家好，我是你们的技术博主 DataWhisperer！今天我们来聊一个既高大上又贴近生活的技术领域：光谱分析技术在环境监测中的应用。  这可不是简单的“看看颜色”就能搞定的，它背后蕴含着丰富的物理学、化学和数学原理，并且在保护我们的环境方面发挥着越来越重要的作用。 引言：光谱分析 – 环境监测的“火眼金睛” 环境监测的目标是及时、准确地获取环境污染物的信息，为环境保护和管理提供科学依据。传统监测方法往往费时费力，且灵敏度有限。而光谱分析技术，凭借其快速、灵敏、多组分同时检测等优点，成为了环境监测领域的一匹黑马。  它利用物质与电磁辐射相互作用的特性，分析物质的成分和结构，从而实现对环境污染物的精准识别和定量分析。 光谱分析技术的种类及原理 光谱分析技术涵盖多种方法，根据所用电磁波的波长范围不同，可以分为： 紫外-可见光谱法 (UV-Vis) UV-Vis 光谱法利用物质对紫外和可见光区域电磁波的吸收特性进行分析。  不同物质具有独特的吸收光谱，通过测量吸收光谱的特征峰，可以确定物质的种类和浓度。  这在水质监测中应用广泛，例如检测重金属离子、有机污染物等。  其原理基于朗伯-比...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082903/" title="计算化学模拟分子间相互作用：从经典力场到量子力学"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">计算化学模拟分子间相互作用：从经典力场到量子力学</div></div><div class="info-2"><div class="info-item-1">引言 分子间相互作用是化学和生物学领域的核心概念，它支配着物质的物理和化学性质，例如溶解度、沸点、蛋白质折叠等等。精确地模拟这些相互作用对于理解和预测分子行为至关重要。计算化学为我们提供了一套强大的工具来研究分子间相互作用，从经典的力场方法到复杂的量子力学计算，本文将深入探讨这些方法及其应用。 经典力场方法 经典力场方法基于牛顿力学，将分子简化为一系列原子，并通过经验参数化的势能函数来描述原子间的相互作用。这种方法计算效率高，适用于模拟大量的原子和分子，例如蛋白质、DNA和材料科学中的大分子体系。 势能函数 经典力场通常包含以下几种类型的相互作用项：  键伸缩 (Bond Stretching): 描述键长偏离平衡键长的能量变化，通常用谐振势能函数表示：Ebond=12kb(r−r0)2E_{bond} = \frac{1}{2}k_b(r - r_0)^2Ebond​=21​kb​(r−r0​)2，其中 kbk_bkb​ 是力常数，rrr 是键长，r0r_0r0​ 是平衡键长。 键角弯曲 (Angle Bending): 描述键角偏离平衡键角的能量变化，通常也用谐振势能函数表示...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082912/" title="绿色化学与可持续发展目标：技术与未来的融合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">绿色化学与可持续发展目标：技术与未来的融合</div></div><div class="info-2"><div class="info-item-1">近年来，可持续发展已成为全球关注的焦点，联合国提出的17个可持续发展目标 (SDGs) 为全球共同努力提供了蓝图。其中，许多目标都与化学工业息息相关，而绿色化学作为一种旨在减少或消除有害物质使用的化学方法，扮演着至关重要的角色。本文将探讨绿色化学如何为实现可持续发展目标做出贡献，并从技术角度深入分析其应用。 绿色化学的十二原则：通向可持续未来的基石 绿色化学的核心是其十二项原则，这些原则指导着化学家的研究和工业生产，力求最大限度地减少环境影响。这些原则并非相互独立，而是相互关联，共同构成了一个整体的框架。 预防原则 这是绿色化学的首要原则，强调在化学反应的设计阶段就应避免产生有害物质，而非在产生后进行处理。这需要化学家们从根本上重新思考化学反应的设计和工艺流程。 原子经济性 理想情况下，所有反应物原子都应转化为最终产物，没有任何浪费。原子经济性是衡量化学反应效率的重要指标，其计算公式为： 原子经济性=目标产物的分子量所有反应物的分子量总和×100%原子经济性 = \frac{目标产物的分子量}{所有反应物的分子量总和} \times 100\%原子经济性=所有反应物的分子量总和目...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">qmwneb946</div><div class="author-info-description">一个专注于技术分享的个人博客，涵盖编程、算法、系统设计等内容</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">738</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">742</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qmwneb946"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/qmwneb946" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:qmwneb946@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">代码与远方，技术与生活交织的篇章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">机器人路径规划概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是路径规划？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.2.</span> <span class="toc-text">路径规划的挑战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">计算几何基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是计算几何？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%87%A0%E4%BD%95%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">核心几何概念与数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">基本几何算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.</span> <span class="toc-text">路径规划中的几何表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.1.</span> <span class="toc-text">环境表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.2.</span> <span class="toc-text">机器人表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">典型的计算几何路径规划算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%87%A0%E4%BD%95%E7%BB%93%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">基于图搜索的算法与几何结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E5%BC%8F%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">采样式规划算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BB%86%E8%83%9E%E5%88%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">基于细胞分解的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9C%A8%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">计算几何在路径规划中的关键技术点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%EF%BC%88Collision-Detection%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">碰撞检测（Collision Detection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%9C%80%E8%BF%91%E9%82%BB%E6%90%9C%E7%B4%A2"><span class="toc-number">5.2.</span> <span class="toc-text">距离计算与最近邻搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">5.3.</span> <span class="toc-text">几何变换与坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%B9%B3%E6%BB%91%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text">路径平滑与优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">案例分析与应用实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98%E4%B8%8E%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91"><span class="toc-number">7.</span> <span class="toc-text">挑战与未来方向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">8.</span> <span class="toc-text">结论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/hello-world/" title="Hello World">Hello World</a><time datetime="2025-07-23T15:52:54.196Z" title="发表于 2025-07-23 23:52:54">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="博弈论基础">博弈论基础</a><time datetime="2025-07-23T15:52:54.196Z" title="发表于 2025-07-23 23:52:54">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/2025-07-23-155006/" title="探索混沌与复杂性的交汇：耦合映象格子模型深度解析">探索混沌与复杂性的交汇：耦合映象格子模型深度解析</a><time datetime="2025-07-23T07:50:06.000Z" title="发表于 2025-07-23 15:50:06">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/2025-07-23-154859/" title="揭秘数字签名的核心：深入理解椭圆曲线数字签名算法（ECDSA）">揭秘数字签名的核心：深入理解椭圆曲线数字签名算法（ECDSA）</a><time datetime="2025-07-23T07:48:59.000Z" title="发表于 2025-07-23 15:48:59">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/2025-07-23-154804/" title="网络模体及其功能：复杂系统中的“基因”与“语法”">网络模体及其功能：复杂系统中的“基因”与“语法”</a><time datetime="2025-07-23T07:48:04.000Z" title="发表于 2025-07-23 15:48:04">2025-07-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By qmwneb946</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'qmwneb946/blog',
      'data-repo-id': 'R_kgDOPM6cWw',
      'data-category-id': 'DIC_kwDOPM6cW84CtEzo',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>