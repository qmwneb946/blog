<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux内核调度器：掌控计算脉搏的艺术 | qmwneb946 的博客</title><meta name="author" content="qmwneb946"><meta name="copyright" content="qmwneb946"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="你好，技术爱好者们！我是 qmwneb946，今天我们将一同踏上一段深度探索之旅，潜入 Linux 内核最核心、也最精妙的组件之一：调度器。如果你曾好奇操作系统是如何在毫秒间协调成千上万的任务，让你的计算机既能流畅播放视频，又能同时编译代码，还能响应你的每一次按键，那么你来对地方了。调度器，正是这一切魔法的幕后英雄。 引言：计算的指挥家 在现代计算机系统中，我们几乎不会只运行一个程序。浏览器、ID">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核调度器：掌控计算脉搏的艺术">
<meta property="og:url" content="https://qmwneb946.dpdns.org/2025/07/24/2025-07-24-215527/index.html">
<meta property="og:site_name" content="qmwneb946 的博客">
<meta property="og:description" content="你好，技术爱好者们！我是 qmwneb946，今天我们将一同踏上一段深度探索之旅，潜入 Linux 内核最核心、也最精妙的组件之一：调度器。如果你曾好奇操作系统是如何在毫秒间协调成千上万的任务，让你的计算机既能流畅播放视频，又能同时编译代码，还能响应你的每一次按键，那么你来对地方了。调度器，正是这一切魔法的幕后英雄。 引言：计算的指挥家 在现代计算机系统中，我们几乎不会只运行一个程序。浏览器、ID">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qmwneb946.dpdns.org/img/icon.png">
<meta property="article:published_time" content="2025-07-24T13:55:27.000Z">
<meta property="article:modified_time" content="2025-07-26T06:59:51.354Z">
<meta property="article:author" content="qmwneb946">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="Linux内核的调度器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qmwneb946.dpdns.org/img/icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux内核调度器：掌控计算脉搏的艺术",
  "url": "https://qmwneb946.dpdns.org/2025/07/24/2025-07-24-215527/",
  "image": "https://qmwneb946.dpdns.org/img/icon.png",
  "datePublished": "2025-07-24T13:55:27.000Z",
  "dateModified": "2025-07-26T06:59:51.354Z",
  "author": [
    {
      "@type": "Person",
      "name": "qmwneb946",
      "url": "https://github.com/qmwneb946"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qmwneb946.dpdns.org/2025/07/24/2025-07-24-215527/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux内核调度器：掌控计算脉搏的艺术',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2845632165165414" crossorigin="anonymous"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="qmwneb946 的博客" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">qmwneb946 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux内核调度器：掌控计算脉搏的艺术</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Linux内核调度器：掌控计算脉搏的艺术<a class="post-edit-link" href="https://github.com/qmwneb946/blog/edit/main/source/_posts/2025-07-24-215527.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-24T13:55:27.000Z" title="发表于 2025-07-24 21:55:27">2025-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-26T06:59:51.354Z" title="更新于 2025-07-26 14:59:51">2025-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>你好，技术爱好者们！我是 qmwneb946，今天我们将一同踏上一段深度探索之旅，潜入 Linux 内核最核心、也最精妙的组件之一：<strong>调度器</strong>。如果你曾好奇操作系统是如何在毫秒间协调成千上万的任务，让你的计算机既能流畅播放视频，又能同时编译代码，还能响应你的每一次按键，那么你来对地方了。调度器，正是这一切魔法的幕后英雄。</p>
<h2 id="引言：计算的指挥家">引言：计算的指挥家</h2>
<p>在现代计算机系统中，我们几乎不会只运行一个程序。浏览器、IDE、音乐播放器、后台服务……它们仿佛在争夺CPU这块宝贵的资源。如果没有一个高效、公平的调度器，系统将陷入混乱，响应迟钝，甚至完全崩溃。</p>
<p>Linux 内核调度器，顾名思义，是 Linux 操作系统的核心组成部分，负责决定在给定时间点哪个进程或线程应该被允许在 CPU 上运行，以及运行多长时间。它的目标是确保所有任务都能获得足够的 CPU 时间，同时满足各种需求：例如，交互式应用需要快速响应，批处理任务需要高吞吐量，而实时应用则要求严格的时间保证。</p>
<p>Linux 的调度器经历了漫长的演进。从最初简单的轮询调度，到旨在优化服务器负载的 O(1) 调度器，再到如今被誉为“完全公平”的 CFS (Completely Fair Scheduler)，以及为满足严苛时间要求的实时调度器，每一个阶段都凝结了工程师们对操作系统性能和用户体验的深刻理解与不懈追求。</p>
<p>本文将带领你深入理解 Linux 调度器的设计哲学、核心算法、数据结构以及它们是如何协同工作的。我们将从最基本的调度概念开始，逐步揭开 CFS 的神秘面纱，探讨实时调度器的特殊性，并简要介绍其他调度类及其在现代 Linux 系统中的作用。最后，我们还会触及调度器性能优化与调试的一些实践。准备好了吗？让我们开始这段硬核之旅！</p>
<h2 id="第一章：调度器的核心概念与挑战">第一章：调度器的核心概念与挑战</h2>
<p>在深入探讨 Linux 调度器的具体实现之前，我们首先需要建立一些基础概念，理解调度器所面临的问题和其设计所追求的目标。</p>
<h3 id="进程与线程：调度的基本单位">进程与线程：调度的基本单位</h3>
<p>在 Linux 中，调度的基本单位是 <strong>线程</strong> (thread)，而不是传统意义上的进程 (process)。在 Linux 内核中，进程和线程都被视为 <code>task_struct</code> 结构体的实例，它们之间唯一的区别在于资源共享的程度。通常，我们将独立拥有地址空间、文件句柄等资源的 <code>task_struct</code> 称为进程，而共享父进程大部分资源的 <code>task_struct</code> 称为线程。调度器并不关心 <code>task_struct</code> 是进程还是线程，它只负责分配 CPU 时间。</p>
<h3 id="CPU-调度的目标">CPU 调度的目标</h3>
<p>一个优秀的 CPU 调度器需要平衡多重目标：</p>
<ul>
<li><strong>公平性 (Fairness):</strong> 确保所有任务都能获得合理的 CPU 时间，避免饥饿。这对于多用户、多任务系统至关重要。</li>
<li><strong>吞吐量 (Throughput):</strong> 单位时间内完成的任务数量。调度器应最大化 CPU 利用率，减少空闲时间。</li>
<li><strong>周转时间 (Turnaround Time):</strong> 从任务提交到任务完成的总时间。应尽量缩短。</li>
<li><strong>等待时间 (Waiting Time):</strong> 任务在就绪队列中等待 CPU 的总时间。应尽量缩短。</li>
<li><strong>响应时间 (Response Time):</strong> 从用户请求到系统产生第一个响应的时间。对于交互式应用至关重要。</li>
<li><strong>优先级 (Priority):</strong> 能够根据任务的重要性或紧急程度分配不同的 CPU 时间。</li>
<li><strong>可预测性 (Predictability):</strong> 特别是对实时系统，调度行为必须是可预测的，确保任务在规定时间内完成。</li>
</ul>
<p>这些目标往往是相互冲突的。例如，追求极致的吞吐量可能意味着牺牲某些任务的公平性和响应时间。调度器的艺术就在于如何在这些目标之间找到最佳的平衡点。</p>
<h3 id="抢占式调度">抢占式调度</h3>
<p>现代操作系统，包括 Linux，都采用<strong>抢占式调度</strong> (Preemptive Scheduling)。这意味着，一个正在运行的任务可以在其时间片未用完之前被调度器暂停，以便让更高优先级的任务或另一个等待时间过长的任务运行。非抢占式调度（协作式调度）中，任务必须自愿放弃 CPU，这会导致响应迟钝甚至系统冻结。</p>
<p>抢占的发生通常在以下几种情况：</p>
<ul>
<li><strong>时钟中断 (Timer Interrupt):</strong> 定期触发，让调度器检查是否需要切换任务。</li>
<li><strong>I/O 完成 (I/O Completion):</strong> 某个任务等待的 I/O 操作完成，它变为可运行状态。</li>
<li><strong>系统调用 (System Call):</strong> 任务执行系统调用，可能进入睡眠状态或被更高优先级任务抢占。</li>
<li><strong>进程状态改变 (Process State Change):</strong> 任务从睡眠状态唤醒。</li>
</ul>
<h3 id="上下文切换-Context-Switching">上下文切换 (Context Switching)</h3>
<p>当调度器决定从一个任务切换到另一个任务时，它必须执行一个称为<strong>上下文切换</strong>的操作。这包括：</p>
<ol>
<li>保存当前运行任务的 CPU 寄存器状态、程序计数器 (PC) 和栈指针 (SP)。</li>
<li>更新当前任务的 <code>task_struct</code> 中的状态信息。</li>
<li>加载下一个任务的 CPU 寄存器状态、PC 和 SP。</li>
<li>更新内存管理单元 (MMU) 的页表基址寄存器，切换到新任务的地址空间（如果新任务属于不同的进程）。</li>
</ol>
<p>上下文切换是纯粹的开销，因为它不执行任何有用的工作。频繁的上下文切换会降低系统性能。因此，调度器需要在这与保持系统响应性之间找到一个平衡。</p>
<h3 id="调度策略与优先级">调度策略与优先级</h3>
<p>Linux 提供了多种调度策略，每种策略都适用于不同类型的任务：</p>
<ul>
<li><strong>分时调度 (Time-sharing Scheduling):</strong> 适用于普通用户任务，追求公平性、响应性和吞吐量的平衡。Linux 的 CFS 就属于此类。</li>
<li><strong>实时调度 (Real-time Scheduling):</strong> 适用于对时间要求严格的任务，如音视频处理、工业控制。实时任务具有最高的优先级，并保证在特定时间内运行。</li>
<li><strong>批处理调度 (Batch Scheduling):</strong> 适用于非交互式、CPU 密集型任务，主要目标是最大化吞吐量，可忍受较长的响应时间。</li>
<li><strong>空闲调度 (Idle Scheduling):</strong> 系统无其他任务可运行时运行的最低优先级任务。</li>
</ul>
<p>在 Linux 中，任务的优先级分为两种：</p>
<ul>
<li><strong>实时优先级 (Real-time Priority):</strong> 范围从 0 到 99，数值越大优先级越高。只对 <code>SCHED_FIFO</code> 和 <code>SCHED_RR</code> 策略有效。</li>
<li><strong>Nice 值 (Nice Value):</strong> 范围从 -20 到 19，默认值为 0。数值越小表示“越不 nice”，即优先级越高。只对 <code>SCHED_OTHER</code> (CFS) 策略有效。<code>nice</code> 值影响任务获得的 CPU 时间权重。</li>
</ul>
<p>理解这些基本概念是理解 Linux 调度器复杂性的第一步。现在，让我们深入 Linux 调度器的历史，看看它是如何一步步发展到今天的。</p>
<h2 id="第二章：Linux-调度器的历史演进">第二章：Linux 调度器的历史演进</h2>
<p>Linux 调度器并非一蹴而就，它随着 Linux 内核的发展而不断演进，以适应更复杂的硬件和更多样化的工作负载。</p>
<h3 id="早期调度器：朴素而直接">早期调度器：朴素而直接</h3>
<p>Linux 内核早期（如 2.4 版本之前）的调度器相对简单，通常采用<strong>基于时间片和循环队列</strong> (Round-Robin) 的方法。每个任务被分配一个固定或可变的时间片，当时间片用完或者任务阻塞时，调度器会切换到下一个任务。优先级通过调整时间片大小来实现。</p>
<p>这种简单调度器在早期内核中表现尚可，但在多处理器系统和高并发负载下，效率低下且扩展性差。主要问题包括：</p>
<ul>
<li><strong>时间复杂度高：</strong> 每次调度都需要遍历就绪队列，随着任务数量增加，调度开销显著上升，导致时间复杂度趋近于 O(N)。</li>
<li><strong>公平性问题：</strong> 简单的时间片分配难以精确控制不同优先级任务的公平性。</li>
<li><strong>缓存利用率低：</strong> 频繁的上下文切换和不合理的任务切换模式可能导致 CPU 缓存失效，影响性能。</li>
</ul>
<h3 id="O-1-调度器：性能的飞跃">O(1) 调度器：性能的飞跃</h3>
<p>为了解决早期调度器在大规模系统中的性能瓶颈，Ingo Molnar 在 Linux 2.6 版本引入了革命性的 <strong>O(1) 调度器</strong>。其核心设计思想是：无论就绪队列中有多少任务，调度一个任务的时间复杂度都保持为常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>O(1) 调度器通过以下关键特性实现了这一目标：</p>
<ul>
<li><strong>运行队列 (Runqueue):</strong> 每个 CPU 都有一个独立的运行队列 <code>runqueue</code>。这样做是为了减少锁竞争，提高多核系统下的扩展性。</li>
<li><strong>优先级数组 (Priority Arrays):</strong> 运行队列中包含两个优先级数组：<code>active</code> 数组和 <code>expired</code> 数组。每个数组有 140 个链表（对应 140 个优先级，其中 0-99 是实时优先级，100-139 是普通优先级）。每个链表存储相同优先级的任务。</li>
<li><strong>位图 (Bitmap):</strong> 每个优先级数组还有一个位图，记录哪些优先级链表是非空的，这使得调度器可以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内找到最高优先级的非空链表。</li>
</ul>
<p><strong>O(1) 调度器的工作原理：</strong></p>
<ol>
<li>调度器从 <code>active</code> 数组中查找优先级最高的非空链表。</li>
<li>选择该链表的第一个任务执行。</li>
<li>当任务的时间片用完或任务阻塞时，将其从 <code>active</code> 数组中移除。</li>
<li>如果任务时间片用完但仍可运行，则计算其新的优先级和时间片，并将其放入 <code>expired</code> 数组中对应的优先级链表。</li>
<li>当 <code>active</code> 数组变为空时，调度器将 <code>active</code> 和 <code>expired</code> 数组指针互换，即 <code>expired</code> 变为 <code>active</code>，开始新的调度周期。</li>
</ol>
<p><strong>O(1) 调度器的优点：</strong></p>
<ul>
<li><strong>常数时间复杂度：</strong> 无论任务数量多少，调度操作都非常快。</li>
<li><strong>更好的实时性：</strong> 实时任务可以直接放置在高优先级队列，确保快速响应。</li>
<li><strong>多核扩展性：</strong> 每个 CPU 独立的运行队列减少了锁粒度。</li>
</ul>
<p><strong>O(1) 调度器的缺点：</strong></p>
<p>尽管 O(1) 调度器带来了显著的性能提升，但它在处理<strong>交互式任务</strong>时仍有不足。其主要问题在于：</p>
<ul>
<li><strong>启发式算法复杂：</strong> 为了区分交互式任务和批处理任务，O(1) 调度器使用了复杂的启发式算法，通过跟踪任务的睡眠时间来判断其“交互性”，进而调整其动态优先级和时间片。这些启发式算法难以微调，容易出现误判，导致交互性较差的任务响应不及时，或批处理任务占用过多 CPU。</li>
<li><strong>公平性难以精确控制：</strong> 即使通过优先级调整时间片，也难以在所有任务之间实现真正的“公平”，特别是当任务数量很多时。</li>
</ul>
<p>这些问题促使了下一代调度器——完全公平调度器 (CFS) 的诞生。</p>
<h3 id="完全公平调度器-CFS-Completely-Fair-Scheduler-：公平的革命">完全公平调度器 (CFS - Completely Fair Scheduler)：公平的革命</h3>
<p>在 Linux 2.6.23 版本中，Ingo Molnar 再次带来了革新，用 <strong>CFS</strong> 彻底取代了 O(1) 调度器，成为 Linux 内核的主流调度器。CFS 的设计理念源于一个非常优雅且直观的思路：<strong>模拟一个理想的、无限快的处理器，让所有可运行任务都能同时运行，并且都以各自权重公平地分享 CPU 时间。</strong></p>
<p>为了实现这种“理想的公平”，CFS 引入了 <strong>虚拟运行时 (Virtual Run Time, vruntime)</strong> 的概念。每个任务都有一个 <code>vruntime</code>，表示它“已经”运行了多长时间。调度器总是选择 <code>vruntime</code> 最小（即“最不公平”、“最亏欠 CPU”的）的任务来运行。当一个任务运行后，它的 <code>vruntime</code> 会增加，增加的量不仅取决于实际运行时间，还会根据任务的 <code>nice</code> 值（优先级）进行加权调整。</p>
<p>CFS 使用<strong>红黑树 (Red-Black Tree)</strong> 来存储所有可运行的任务，并根据它们的 <code>vruntime</code> 进行排序。红黑树是一种自平衡二叉查找树，它能确保在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间复杂度内完成插入、删除和查找最小元素的操作，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 是树中的节点数量。这使得 CFS 既能保证公平性，又能保持高效的调度性能。</p>
<p>CFS 极大地简化了调度器的复杂性，移除了 O(1) 调度器中复杂的启发式算法，取而代之的是一个简洁而强大的公平性模型。它的出现标志着 Linux 调度器发展的一个重要里程碑。</p>
<h2 id="第三章：CFS：完全公平的艺术">第三章：CFS：完全公平的艺术</h2>
<p>CFS，全称 Completely Fair Scheduler，是 Linux 内核针对普通（<code>SCHED_OTHER</code>）任务设计的调度器。它不基于时间片，而是通过追踪每个任务的“虚拟运行时”来确保公平性。</p>
<h3 id="CFS-的核心数据结构">CFS 的核心数据结构</h3>
<p>CFS 的核心思想体现在其关键数据结构中：</p>
<h4 id="struct-sched-entity：调度实体"><code>struct sched_entity</code>：调度实体</h4>
<p>在 CFS 中，调度的基本单位不再是 <code>task_struct</code> 本身，而是一个更抽象的调度实体 <code>sched_entity</code>。每个 <code>task_struct</code> 内部都包含一个 <code>sched_entity</code> 结构体。对于组调度 (Group Scheduling)，一个任务组也可以拥有一个 <code>sched_entity</code>，这使得 CFS 能够以统一的方式处理单个任务和任务组的调度。</p>
<p><code>sched_entity</code> 中最重要的成员是 <code>vruntime</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simplified struct sched_entity</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>      <span class="title">run_node</span>;</span>   <span class="comment">// 红黑树节点</span></span><br><span class="line">    u64                 vruntime;   <span class="comment">// 虚拟运行时</span></span><br><span class="line">    <span class="comment">// ... 其他成员，如负载权重 (load_weight)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>run_node</code>: 用于将 <code>sched_entity</code> 插入到红黑树中。</li>
<li><code>vruntime</code>: 这是一个 64 位无符号整数，表示该调度实体“已经”在理想处理器上运行了多长时间。它的值越大，表示任务获得的 CPU 时间越多，其“亏欠”CPU 的程度就越少。</li>
</ul>
<h4 id="struct-cfs-rq：CFS-运行队列"><code>struct cfs_rq</code>：CFS 运行队列</h4>
<p>每个 CPU 都有一个 <code>cfs_rq</code> 结构体，代表该 CPU 上的 CFS 运行队列。它是管理 <code>sched_entity</code> 的核心：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simplified struct cfs_rq</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>      <span class="title">tasks_timeline</span>;</span> <span class="comment">// 红黑树的根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span>;</span>          <span class="comment">// 当前正在运行的 sched_entity</span></span><br><span class="line">    u64                 min_vruntime;   <span class="comment">// 红黑树中所有任务的最小 vruntime</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        nr_running;     <span class="comment">// 可运行任务的数量</span></span><br><span class="line">    <span class="comment">// ... 其他成员，如组调度相关信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tasks_timeline</code>: 这是存储所有可运行 <code>sched_entity</code> 的<strong>红黑树</strong>的根节点。红黑树的节点以 <code>vruntime</code> 为键进行排序。</li>
<li><code>curr</code>: 指向当前正在 CPU 上运行的 <code>sched_entity</code>。</li>
<li><code>min_vruntime</code>: 记录当前红黑树中所有任务的 <code>vruntime</code> 的最小值。当有新任务加入红黑树时，它的 <code>vruntime</code> 会被初始化为 <code>min_vruntime</code>，以确保它不会立即被调度。</li>
</ul>
<h4 id="红黑树-Red-Black-Tree">红黑树 (Red-Black Tree)</h4>
<p>红黑树是 CFS 实现其公平性的关键。它具有以下特性：</p>
<ul>
<li><strong>自平衡：</strong> 保证树的高度是对数级别的 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>)，因此插入、删除和查找操作的效率很高。</li>
<li><strong>按键排序：</strong> CFS 使用 <code>vruntime</code> 作为键，将 <code>sched_entity</code> 插入到红黑树中。<code>vruntime</code> 越小的节点越靠近树的左侧。</li>
</ul>
<p>调度器总是选择红黑树中最左边的节点（即 <code>vruntime</code> 最小的节点）来运行。这确保了“最亏欠 CPU”的任务总是优先获得 CPU。</p>
<h3 id="vruntime-的计算：公平的量化">vruntime 的计算：公平的量化</h3>
<p><code>vruntime</code> 是 CFS 的灵魂。它不直接代表实际运行时间，而是一个经过<strong>加权</strong>的虚拟时间。</p>
<h4 id="基本原理与加权">基本原理与加权</h4>
<p>当一个任务在 CPU 上运行时，它的 <code>vruntime</code> 会随着实际运行时间的增加而增加。但是，这个增加的速度并不是线性的，而是取决于任务的 <strong>权重 (weight)</strong>，而权重又由任务的 <code>nice</code> 值决定。</p>
<p><code>nice</code> 值的范围是 -20 到 19。<code>nice</code> 值越小（优先级越高），其权重越大，<code>vruntime</code> 增加得越慢；<code>nice</code> 值越大（优先级越低），其权重越小，<code>vruntime</code> 增加得越快。</p>
<p>理想情况下，所有任务都应该以相同的速度增加 <code>vruntime</code>。如果一个任务 <code>A</code> 的权重是任务 <code>B</code> 的两倍，那么在相同的时间内，任务 <code>A</code> 应该获得两倍的 CPU 时间。为了实现这一点，CFS 让**权重大的任务 <code>vruntime</code> 增长慢，权重小的任务 <code>vruntime</code> 增长快。**这样，权重大的任务总是倾向于保持较低的 <code>vruntime</code>，从而获得更多的 CPU 时间。</p>
<p><code>vruntime</code> 的更新公式可以概念化为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mi>r</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><msub><mi>e</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mi>v</mi><mi>r</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><msub><mi>e</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>×</mo><mfrac><mrow><mi>N</mi><mi>I</mi><mi>C</mi><mi>E</mi><mi mathvariant="normal">_</mi><mn>0</mn><mi mathvariant="normal">_</mi><mi>W</mi><mi>E</mi><mi>I</mi><mi>G</mi><mi>H</mi><mi>T</mi></mrow><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>t</mi><mi>a</mi><mi>s</mi><mi>k</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">vruntime_{new} = vruntime_{old} + \Delta t \times \frac{NICE\_0\_WEIGHT}{weight_{task}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.2638em;vertical-align:-0.8804em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3833em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">CE</span><span class="mord" style="margin-right:0.02778em;">_0_</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span></span> 是任务实际运行的时间。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>I</mi><mi>C</mi><mi>E</mi><mi mathvariant="normal">_</mi><mn>0</mn><mi mathvariant="normal">_</mi><mi>W</mi><mi>E</mi><mi>I</mi><mi>G</mi><mi>H</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">NICE\_0\_WEIGHT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.05764em;">CE</span><span class="mord" style="margin-right:0.02778em;">_0_</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 是 <code>nice</code> 值为 0 的任务的默认权重，在 Linux 内核中通常定义为 1024。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mrow><mi>t</mi><mi>a</mi><mi>s</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">weight_{task}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是当前任务的实际权重，它通过 <code>prio_to_weight</code> 数组从 <code>nice</code> 值映射得到。</li>
</ul>
<p>例如，如果一个任务的权重是 <code>NICE_0_WEIGHT</code> 的两倍，那么它的 <code>vruntime</code> 增长速度只有 <code>nice</code> 值为 0 的任务的一半，这意味着它将获得双倍的 CPU 时间。</p>
<p>内核中有一个全局的 <code>sched_prio_to_weight</code> 数组，它存储了 <code>nice</code> 值到权重的映射。例如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Nice 值</th>
<th style="text-align:left">权重 (weight)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-20</td>
<td style="text-align:left">88761</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1024</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left">10</td>
</tr>
</tbody>
</table>
<p>你可以看到，<code>nice</code> 值为 -20 的任务权重是 <code>nice</code> 值为 0 的任务的大约 86 倍，而 <code>nice</code> 值为 19 的任务权重只有 <code>nice</code> 值为 0 的任务的大约 1/100。</p>
<p>内核通过函数 <code>calc_delta_weighted</code> 来计算 <code>vruntime</code> 的增量。其简化逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码: 计算 vruntime 增量</span></span><br><span class="line">u64 <span class="title function_">calc_delta_weighted</span><span class="params">(u64 delta_exec, <span class="type">unsigned</span> <span class="type">long</span> weight, <span class="type">unsigned</span> <span class="type">long</span> nice_0_weight)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (weight == nice_0_weight)</span><br><span class="line">        <span class="keyword">return</span> delta_exec;</span><br><span class="line">    <span class="keyword">if</span> (weight == <span class="number">0</span>) <span class="comment">// 不应该发生，但作为保护</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示最大值，使其尽快被调度走</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 delta_exec 乘以 NICE_0_WEIGHT，然后除以 weight</span></span><br><span class="line">    <span class="comment">// 实际实现中会使用移位和优化，避免大数溢出和浮点运算</span></span><br><span class="line">    <span class="keyword">return</span> (delta_exec * nice_0_weight) / weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调度周期-Scheduler-Period-与最小粒度-Minimum-Granularity">调度周期 (Scheduler Period) 与最小粒度 (Minimum Granularity)</h4>
<p>CFS 引入了两个重要的概念来平衡公平性与响应时间：</p>
<ul>
<li><strong>调度周期 (Scheduler Period):</strong> <code>sysctl_sched_latency_ns</code>。这是一个理想的总周期，表示在所有可运行任务都轮流运行至少一次的情况下，所需要的总时间。默认通常是 6 毫秒 (6,000,000 纳秒)。</li>
<li><strong>最小粒度 (Minimum Granularity):</strong> <code>sysctl_sched_min_granularity_ns</code>。这是单个任务在被抢占前最少应该运行的时间。默认通常是 750 微秒 (750,000 纳秒)。</li>
</ul>
<p>当可运行任务数量较少时，每个任务获得的运行时间是 <code>sysctl_sched_latency_ns / nr_running</code>。<br>
当可运行任务数量很多时，如果按照上述公式计算，每个任务获得的运行时间可能变得非常短，导致频繁的上下文切换开销。因此，CFS 会确保每个任务至少运行 <code>sysctl_sched_min_granularity_ns</code>。<br>
总结来说，任务实际获得的时间片是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>sysctl_sched_min_granularity_ns</mtext><mo separator="true">,</mo><mtext>sysctl_sched_latency_ns</mtext><mi mathvariant="normal">/</mi><mtext>nr_running</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(\text{sysctl\_sched\_min\_granularity\_ns}, \text{sysctl\_sched\_latency\_ns} / \text{nr\_running})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord text"><span class="mord">sysctl_sched_min_granularity_ns</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">sysctl_sched_latency_ns</span></span><span class="mord">/</span><span class="mord text"><span class="mord">nr_running</span></span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="任务的选择与调度">任务的选择与调度</h3>
<p>CFS 的调度逻辑非常直观：</p>
<ol>
<li><strong>选择下一个任务：</strong> <code>pick_next_task_fair()</code> 函数总是从当前 CPU 的 <code>cfs_rq</code> 的红黑树中选择 <code>vruntime</code> 最小（即红黑树最左边的节点）的 <code>sched_entity</code>。这个操作是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的。</li>
<li><strong>更新当前任务的 <code>vruntime</code>：</strong> 当一个任务被调度器从 CPU 上取下时（无论是时间片用完、被抢占还是进入睡眠），调度器会根据它实际运行的时间更新它的 <code>vruntime</code>。</li>
<li><strong>放回红黑树：</strong> 如果任务仍然可运行，它会被放回红黑树。由于其 <code>vruntime</code> 增加了，它在红黑树中的位置会向右移动，让位给其他 <code>vruntime</code> 更小的任务。</li>
<li><strong>抢占：</strong> 当一个新任务被唤醒或者一个阻塞的任务变为可运行状态时，调度器会检查它的 <code>vruntime</code> 是否远小于当前运行任务的 <code>vruntime</code>。如果满足抢占条件（通常是新任务的 <code>vruntime</code> 加上 <code>sysctl_sched_min_granularity_ns</code> 仍然小于当前任务的 <code>vruntime</code>），则立即进行抢占，新任务获得 CPU。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码: pick_next_task_fair() 核心逻辑</span></span><br><span class="line"><span class="keyword">struct</span> sched_entity* <span class="title function_">pick_next_task_fair</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到红黑树最左边的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">leftmost</span> =</span> rb_first(&amp;cfs_rq-&gt;tasks_timeline);</span><br><span class="line">    <span class="keyword">if</span> (!leftmost)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 没有可运行任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 rb_node 转换为 sched_entity 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> rb_entry(leftmost, <span class="keyword">struct</span> sched_entity, run_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 cfs_rq 的 min_vruntime (如果有需要)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> se;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码: put_prev_task_fair() 核心逻辑 (任务被放下CPU)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_prev_task_fair</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *prev)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新 prev 任务的 vruntime (基于实际运行时间)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 prev 任务仍然可运行，将其放回红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;state == TASK_RUNNING) &#123;</span><br><span class="line">        rb_insert_color(&amp;prev-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline, prev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务进入睡眠或结束，从红黑树移除</span></span><br><span class="line">        rb_erase(&amp;prev-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种机制，CFS 确保了所有任务都能“公平地”共享 CPU 时间，而不是严格的平均分配，而是按照它们的权重进行分配。</p>
<h3 id="组调度-Group-Scheduling">组调度 (Group Scheduling)</h3>
<p>随着 Cgroups (Control Groups) 的引入，Linux 内核实现了<strong>组调度</strong>功能。这意味着 CFS 不仅可以在单个任务之间进行公平调度，还可以对<strong>任务组</strong>（例如属于同一个容器的所有进程，或者属于同一个用户的进程）进行公平调度。</p>
<p><strong>实现原理：</strong></p>
<p>组调度的核心在于将 <code>sched_entity</code> 嵌套化。每个 <code>task_struct</code> 包含一个 <code>sched_entity</code>。当任务属于一个任务组时，这个任务组本身也会有一个 <code>sched_entity</code>。任务组的 <code>sched_entity</code> 作为父级调度实体，被插入到其父任务组的 <code>cfs_rq</code> 的红黑树中（如果它有父任务组）。而任务组内部的任务的 <code>sched_entity</code> 则插入到该任务组自己的 <code>cfs_rq</code> 中。</p>
<p><strong>层次化调度过程：</strong></p>
<ol>
<li>当调度器选择一个任务时，它首先从最顶层的 <code>cfs_rq</code>（通常是 CPU 运行队列）中选择 <code>vruntime</code> 最小的 <code>sched_entity</code>。</li>
<li>如果这个 <code>sched_entity</code> 代表一个任务组，调度器会深入到该任务组的 <code>cfs_rq</code> 中，再次选择 <code>vruntime</code> 最小的 <code>sched_entity</code>。这个过程会递归进行，直到找到一个真正的 <code>task_struct</code> 对应的 <code>sched_entity</code>。</li>
<li>被选中的 <code>task_struct</code> 获得 CPU。当它运行后，其 <code>vruntime</code> 和所有祖先任务组的 <code>vruntime</code> 都会相应更新。</li>
</ol>
<p>这使得我们可以对不同用户、不同容器或不同应用组分配不同的 CPU 资源比例。例如，你可以设置“开发组”获得 70% 的 CPU 时间，“测试组”获得 30% 的 CPU 时间，而在这 70% 和 30% 内部，各自的进程再进行公平调度。这极大地提高了资源管理的灵活性和精确性。</p>
<h2 id="第四章：实时调度器：追求极致响应">第四章：实时调度器：追求极致响应</h2>
<p>除了 CFS 处理的普通任务外，Linux 内核还提供了针对<strong>实时任务</strong>的调度器。实时任务对时间有严格的要求，它们必须在规定的截止日期前完成，否则可能导致系统故障或严重后果（例如，飞行控制系统、音视频流处理）。</p>
<h3 id="实时任务的特点">实时任务的特点</h3>
<ul>
<li><strong>确定性 (Determinism):</strong> 任务必须在可预测的时间内完成，无论系统负载如何。</li>
<li><strong>优先级高 (High Priority):</strong> 实时任务通常拥有最高的优先级，能够立即抢占任何非实时任务。</li>
<li><strong>最小延迟 (Low Latency):</strong> 任务从就绪到运行的延迟必须最小化。</li>
<li><strong>可截止期 (Deadlines):</strong> 许多实时任务有明确的完成截止期。</li>
</ul>
<h3 id="Linux-实时调度策略">Linux 实时调度策略</h3>
<p>Linux 内核提供了两种主要的实时调度策略：</p>
<ol>
<li>
<p><strong><code>SCHED_FIFO</code> (先进先出):</strong></p>
<ul>
<li>一旦任务被调度，它会一直运行，直到它自愿放弃 CPU（例如，等待 I/O、睡眠）或被更高优先级的实时任务抢占。</li>
<li>相同优先级的 <code>SCHED_FIFO</code> 任务之间，遵循先进先出原则：先进入就绪队列的任务先运行。</li>
<li>没有时间片概念，除非被抢占，否则可以无限期运行。</li>
</ul>
</li>
<li>
<p><strong><code>SCHED_RR</code> (循环):</strong></p>
<ul>
<li>类似于 <code>SCHED_FIFO</code>，但它引入了<strong>时间片</strong>的概念。</li>
<li>当一个 <code>SCHED_RR</code> 任务的时间片用完时，它会被调度器放到同优先级就绪队列的末尾，让位于其他同优先级的 <code>SCHED_RR</code> 任务。</li>
<li>如果同优先级只有一个 <code>SCHED_RR</code> 任务，它会持续运行直到自愿放弃或被更高优先级任务抢占。</li>
<li>时间片大小可以通过 <code>sched_rr_get_interval()</code> 获取和设置。</li>
</ul>
</li>
</ol>
<p>实时任务的优先级范围是 0 到 99，其中 99 是最高优先级。与 <code>nice</code> 值相反，实时优先级数值越大优先级越高。</p>
<h3 id="实时调度器的运作">实时调度器的运作</h3>
<p>实时调度器维护着一个独立的运行队列 <code>rt_rq</code> (real-time runqueue)。这个运行队列内部有一个优先级数组，类似 O(1) 调度器中的 <code>active</code> 数组，每个索引代表一个实时优先级，并存储一个该优先级下可运行任务的链表。</p>
<p><strong>实时调度器的选择逻辑：</strong></p>
<ol>
<li>调度器总是优先选择实时任务。</li>
<li>在实时任务中，它会选择优先级最高的任务。</li>
<li>如果存在多个同优先级的实时任务：
<ul>
<li>对于 <code>SCHED_FIFO</code> 任务，选择就绪队列中等待时间最长的任务（先进先出）。</li>
<li>对于 <code>SCHED_RR</code> 任务，如果当前运行任务的时间片用尽，将其放到队列末尾，并选择下一个同优先级任务。</li>
</ul>
</li>
</ol>
<p><strong>实时任务的抢占：</strong></p>
<p>实时任务具有强大的抢占能力。一个更高优先级的实时任务可以立即抢占当前正在运行的任何任务，包括：</p>
<ul>
<li>较低优先级的实时任务。</li>
<li>任何 CFS 任务（普通任务）。</li>
</ul>
<p>这意味着，如果一个优先级为 90 的 <code>SCHED_FIFO</code> 任务变得可运行，它将立即抢占一个优先级为 80 的 <code>SCHED_RR</code> 任务，甚至一个 <code>nice</code> 值为 -20 的 CFS 任务。</p>
<p>实时调度器需要谨慎使用，因为它可能导致普通任务的饥饿。如果系统中存在一个设计不当的、长时间运行的高优先级实时任务，它可能会独占 CPU，导致系统响应迟钝，甚至无法进行基本操作。</p>
<h3 id="截止期调度器-SCHED-DEADLINE">截止期调度器 (SCHED_DEADLINE)</h3>
<p>除了 <code>SCHED_FIFO</code> 和 <code>SCHED_RR</code>，Linux 内核还引入了更新的<strong>截止期调度器 (<code>SCHED_DEADLINE</code>)</strong>。这是根据 EDF (Earliest Deadline First) 算法和 CBS (Constant Bandwidth Server) 机制实现的。</p>
<p><strong><code>SCHED_DEADLINE</code> 的特点：</strong></p>
<ul>
<li><strong>基于截止期：</strong> 任务不是通过固定优先级，而是通过三个参数来定义：
<ul>
<li><strong>运行时 (runtime):</strong> 任务在一个周期内最多可以运行多长时间。</li>
<li><strong>截止期 (deadline):</strong> 任务必须完成其运行的截止时间。</li>
<li><strong>周期 (period):</strong> 任务每隔多长时间重复一次。</li>
</ul>
</li>
<li><strong>EDF 算法：</strong> 总是选择即将到达截止期的任务来运行。</li>
<li><strong>CBS 机制：</strong> 确保每个任务在一个周期内不会超过其 <code>runtime</code>，防止一个任务独占 CPU。</li>
</ul>
<p><code>SCHED_DEADLINE</code> 提供比传统实时调度器更精细的控制和更高的可预测性，特别适用于需要严格满足时间约束的场景。它使用红黑树来存储任务，以截止期为键进行排序，最快到达截止期的任务位于红黑树最左侧。</p>
<h2 id="第五章：调度器类与协同工作">第五章：调度器类与协同工作</h2>
<p>Linux 内核的调度器并非单一的组件，而是一个模块化的框架。它通过<strong>调度器类 (Scheduler Class)</strong> 的概念来管理不同类型的调度策略，并让它们协同工作。</p>
<h3 id="调度器类层次结构-sched-class">调度器类层次结构 (<code>sched_class</code>)</h3>
<p>内核定义了一个 <code>sched_class</code> 结构体，每个调度器策略（如 CFS、实时调度、空闲调度等）都实现这个接口。这些调度器类形成一个链表，按照优先级从高到低排列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码: 调度器类结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个调度器类</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*yield_task) (<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">bool</span> (*check_preempt_curr) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_next_task</span>) (<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, <span class="keyword">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>);</span></span><br><span class="line">    <span class="type">void</span> (*put_prev_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line">    <span class="comment">// ... 更多钩子函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当调度器需要选择下一个任务时，它会从最高优先级的调度器类开始遍历链表，询问每个类是否有任务可调度。如果当前调度器类没有可调度任务，或者它选择了一个任务但发现该任务的优先级不够高，则会继续询问下一个调度器类。</p>
<p>目前 Linux 内核中的调度器类按优先级从高到低排列大致如下：</p>
<ol>
<li><strong><code>stop_sched_class</code> (<code>SCHED_STOP</code>):</strong> 优先级最高，用于停止其他所有任务，通常用于 CPU 热插拔或系统关机等极端情况。</li>
<li><strong><code>dl_sched_class</code> (<code>SCHED_DEADLINE</code>):</strong> 截止期调度类，优先级次高，保证截止期任务的执行。</li>
<li><strong><code>rt_sched_class</code> (<code>SCHED_FIFO</code>, <code>SCHED_RR</code>):</strong> 实时调度类，处理实时任务。</li>
<li><strong><code>fair_sched_class</code> (<code>SCHED_OTHER</code>, <code>SCHED_BATCH</code>):</strong> CFS 调度类，处理普通分时任务和批处理任务。</li>
<li><strong><code>idle_sched_class</code> (<code>SCHED_IDLE</code>):</strong> 空闲调度类，优先级最低，当没有其他任何任务可运行时，CPU 进入空闲状态。</li>
</ol>
<p>这种分层的设计使得不同类型的任务可以共存于一个系统中，并且调度器能够确保高优先级任务的及时执行，同时仍能公平地处理普通任务。</p>
<h3 id="中断上下文中的调度">中断上下文中的调度</h3>
<p>Linux 内核中有两种中断上下文：<strong>硬中断 (Hard IRQ)</strong> 和 <strong>软中断 (Soft IRQ)</strong>。</p>
<ul>
<li><strong>硬中断：</strong> 发生时会立即抢占当前执行的任务，执行对应的中断服务程序 (ISR)。ISR 应该尽可能短，不应该执行耗时操作，也不允许睡眠。因此，在硬中断上下文中<strong>不允许调度</strong>。</li>
<li><strong>软中断：</strong> 硬中断处理完成后，可以调度执行软中断。软中断在内核态执行，可以在一个特殊的内核线程 (<code>ksoftirqd</code>) 中运行，或者在其他进程的上下文中运行。软中断可以执行耗时操作，但是仍然不能睡眠。通常，网络数据包处理、块设备 I/O 完成等都通过软中断处理。软中断可以触发调度。</li>
</ul>
<p><strong>工作队列 (Workqueue)</strong> 和 <strong>任务队列 (Tasklet)</strong> 也是内核中常用的延迟处理机制，它们通常在软中断或特殊的内核线程中执行。这些机制本身不直接进行调度，但它们所提交的工作最终可能导致任务状态改变，进而触发调度器进行任务切换。</p>
<h3 id="空闲调度器-SCHED-IDLE">空闲调度器 (<code>SCHED_IDLE</code>)</h3>
<p>当一个 CPU 上没有任何可运行的任务时，调度器会选择 <code>idle_sched_class</code>，并运行一个特殊的<strong>空闲任务 (idle task)</strong>。这个空闲任务通常会执行 <code>hlt</code> (halt) 指令，让 CPU 进入低功耗状态，直到有新的任务唤醒 CPU。这是节能的关键机制。</p>
<h3 id="唤醒-Wakeup-机制与调度">唤醒 (Wakeup) 机制与调度</h3>
<p>任务从睡眠状态变为可运行状态的过程称为<strong>唤醒 (Wakeup)</strong>。当一个任务被唤醒时，内核会调用 <code>try_to_wake_up()</code> 函数，它会执行以下关键步骤：</p>
<ol>
<li>将任务状态从睡眠状态（如 <code>TASK_INTERRUPTIBLE</code> 或 <code>TASK_UNINTERRUPTIBLE</code>）设置为 <code>TASK_RUNNING</code>。</li>
<li>将任务放入其所属 CPU 的运行队列（通过调用对应调度类的 <code>enqueue_task</code> 函数，例如 CFS 的 <code>enqueue_task_fair</code> 或实时调度器的 <code>enqueue_task_rt</code>）。</li>
<li>检查是否需要立即抢占当前正在运行的任务。如果新唤醒的任务优先级高于当前任务，或者其 <code>vruntime</code> 显著小于当前 CFS 任务，调度器会设置一个抢占标志，触发一次调度。</li>
</ol>
<p>例如，在 CFS 中，<code>check_preempt_curr_fair()</code> 会比较新唤醒任务的 <code>vruntime</code> 和当前运行任务的 <code>vruntime</code>。如果新任务的 <code>vruntime</code> 显著更小，则会触发抢占。</p>
<h3 id="CPU-拓扑感知调度：NUMA-与-SMP">CPU 拓扑感知调度：NUMA 与 SMP</h3>
<p>现代服务器通常是多核处理器 (SMP - Symmetric Multi-Processing) 或非统一内存访问架构 (NUMA - Non-Uniform Memory Access)。调度器必须感知这些拓扑结构以优化性能：</p>
<ul>
<li><strong>SMP 优化：</strong>
<ul>
<li><strong>CPU 亲和性 (CPU Affinity):</strong> 任务倾向于在同一 CPU 上运行，以最大化缓存命中率，减少上下文切换开销。</li>
<li><strong>负载均衡 (Load Balancing):</strong> 当某些 CPU 的负载过高时，调度器会将任务迁移到负载较低的 CPU，以提高整体吞吐量。这涉及到复杂的算法来决定何时以及如何迁移任务，以平衡负载和缓存亲和性。</li>
</ul>
</li>
<li><strong>NUMA 优化：</strong>
<ul>
<li><strong>内存亲和性：</strong> 任务应尽可能在访问本地内存的 CPU 上运行，以避免跨 NUMA 节点访问内存带来的高延迟。</li>
<li>调度器会尽量将任务调度到其上次运行的 CPU 或与其内存所在 NUMA 节点关联的 CPU 上。</li>
</ul>
</li>
</ul>
<p>这些优化通过 <code>sched_domain</code> 结构体和相关的负载均衡算法实现，确保任务在正确的地方运行，以获得最佳性能。</p>
<h2 id="第六章：调度器性能优化与调试">第六章：调度器性能优化与调试</h2>
<p>理解 Linux 调度器的工作原理是第一步，接下来是如何对其进行监控、分析和调优，以满足特定工作负载的需求。</p>
<h3 id="调度器参数调优-sysctl">调度器参数调优 (<code>sysctl</code>)</h3>
<p>Linux 内核提供了许多 <code>sysctl</code> 参数，可以通过 <code>/proc/sys/kernel/</code> 路径访问和修改，从而影响调度器行为。</p>
<p>一些重要的 CFS 参数包括：</p>
<ul>
<li><code>/proc/sys/kernel/sched_latency_ns</code>: CFS 调度周期，默认 6,000,000 纳秒 (6ms)。</li>
<li><code>/proc/sys/kernel/sched_min_granularity_ns</code>: 单个任务最少运行时间，默认 750,000 纳秒 (0.75ms)。</li>
<li><code>/proc/sys/kernel/sched_wakeup_granularity_ns</code>: 唤醒抢占的最小粒度，默认 1,000,000 纳秒 (1ms)。当新唤醒任务的 <code>vruntime</code> 比当前任务的 <code>vruntime</code> 低于这个值时，就会触发抢占。</li>
</ul>
<p>对于实时调度器：</p>
<ul>
<li><code>/proc/sys/kernel/sched_rt_period_us</code>: 实时调度周期，默认 1,000,000 微秒 (1s)。</li>
<li><code>/proc/sys/kernel/sched_rt_runtime_us</code>: 实时任务在 <code>sched_rt_period_us</code> 内可以运行的总时间，默认 950,000 微秒 (0.95s)。这意味着实时任务最多可以使用 95% 的 CPU 时间，留下 5% 给普通任务，以避免实时任务导致系统饥饿。</li>
</ul>
<p><strong>注意事项：</strong> 随意修改这些参数可能导致系统不稳定或性能下降。通常，只有在深入理解调度器和工作负载特性后，才应尝试调整这些参数。</p>
<h3 id="perf-工具：性能分析利器"><code>perf</code> 工具：性能分析利器</h3>
<p><code>perf</code> 是 Linux 下强大的性能分析工具，它能够收集 CPU 性能计数器事件，并对内核和用户空间的性能进行深入分析。对于调度器，<code>perf</code> 可以用来：</p>
<ul>
<li><strong>分析上下文切换：</strong> <code>perf sched record</code> 和 <code>perf sched latency</code> 可以记录和分析上下文切换的事件和延迟。</li>
<li><strong>分析调度器热点：</strong> <code>perf top</code> 或 <code>perf record -g</code> 可以找出调度器函数（如 <code>__schedule()</code>、<code>pick_next_task_fair()</code>）的 CPU 占用情况。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录调度器事件</span></span><br><span class="line"><span class="built_in">sudo</span> perf <span class="built_in">sched</span> record</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析调度器延迟</span></span><br><span class="line"><span class="built_in">sudo</span> perf <span class="built_in">sched</span> latency</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最耗时的调度函数</span></span><br><span class="line"><span class="built_in">sudo</span> perf top -F 99 -e cpu-cycles -s <span class="built_in">comm</span>,dso --call-graph dwarf</span><br></pre></td></tr></table></figure>
<h3 id="ftrace-跟踪：深入内核事件"><code>ftrace</code> 跟踪：深入内核事件</h3>
<p><code>ftrace</code> 是 Linux 内核内置的跟踪框架，它允许你在内核运行时跟踪各种事件和函数调用。它是诊断调度器行为的终极工具。</p>
<p>你可以使用 <code>ftrace</code> 来：</p>
<ul>
<li><strong>跟踪调度事件：</strong> 开启 <code>sched_switch</code>、<code>sched_wakeup</code> 等事件，查看任务何时被切换、何时被唤醒。</li>
<li><strong>跟踪函数调用：</strong> 跟踪特定调度器函数的执行路径。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启调度器事件跟踪</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/sched/sched_switch/enable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启函数跟踪（例如，跟踪 pick_next_task_fair）</span></span><br><span class="line"><span class="built_in">echo</span> pick_next_task_fair &gt; /sys/kernel/debug/tracing/set_ftrace_filter</span><br><span class="line"><span class="built_in">echo</span> <span class="keyword">function</span> &gt; /sys/kernel/debug/tracing/current_tracer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行你的程序，然后查看跟踪日志</span></span><br><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理跟踪</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/kernel/debug/tracing/events/sched/sched_switch/enable</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable</span><br><span class="line"><span class="built_in">echo</span> nop &gt; /sys/kernel/debug/tracing/current_tracer</span><br><span class="line"><span class="built_in">echo</span> &gt; /sys/kernel/debug/tracing/set_ftrace_filter</span><br></pre></td></tr></table></figure>
<p><code>ftrace</code> 的输出非常详细，需要一定经验来解读，但它能提供最接近真相的调度器行为视图。</p>
<h3 id="调试技巧">调试技巧</h3>
<ul>
<li><strong><code>/proc/&lt;pid&gt;/sched</code>:</strong> 查看特定进程的调度信息，包括其 <code>vruntime</code>、优先级、CPU 使用情况等。</li>
<li><strong><code>/proc/sched_debug</code>:</strong> 提供一个全局的调度器状态报告，包括每个 CPU 的运行队列状态、<code>min_vruntime</code> 等。</li>
<li><strong><code>debugfs</code>:</strong> 如果内核编译时开启了 <code>CONFIG_SCHED_DEBUG</code>，会在 <code>debugfs</code> 目录下暴露更多调度器相关的调试信息。</li>
<li><strong><code>printk</code>：</strong> 在内核代码中添加 <code>printk</code> 语句（但请谨慎，过多 <code>printk</code> 会影响性能）。</li>
</ul>
<p>通过这些工具和技巧，你可以深入了解 Linux 调度器在你的系统上如何工作，识别性能瓶颈，并进行有针对性的优化。</p>
<h2 id="结论：掌控计算的脉搏">结论：掌控计算的脉搏</h2>
<p>至此，我们已经深入探讨了 Linux 内核调度器的方方面面。从核心概念到其历史演进，从 CFS 的完全公平艺术到实时调度器的极致响应，再到各种调度类的协同工作和性能调优手段，我们看到了一个高度复杂但又极其精妙的系统。</p>
<p>Linux 调度器是 Linux 内核的杰作之一。它以其优雅的设计，特别是 CFS 的 <code>vruntime</code> 和红黑树机制，在保证公平性的同时，实现了卓越的性能和扩展性。它在保证系统响应性和高吞吐量之间找到了一个近乎完美的平衡，使得 Linux 能够胜任从嵌入式设备到超级计算机的各种计算任务。</p>
<p>理解调度器不仅能帮助我们更深入地理解操作系统的运行机制，也能指导我们在开发高性能应用时，如何编写“调度器友好”的代码。例如，避免长时间的 CPU 密集型循环（除非你是批处理任务），合理使用多线程，并利用优先级和亲和性设置来优化任务性能。</p>
<p>调度器并非一成不变。随着新的硬件架构（如异构计算、更多核心、更深层次的 NUMA 结构）和新的工作负载（如容器化、边缘计算、AI/ML 推理）的出现，Linux 调度器也在不断发展和适应。未来，我们可能会看到更多对能效、QoS (Quality of Service) 和特定硬件加速器感知的调度器优化。</p>
<p>希望这篇博文能为你打开 Linux 调度器的大门，让你对这个默默无闻却至关重要的组件有一个全面的认识。下一次当你看到系统流畅运行时，不妨想想，这背后正是 Linux 调度器在精确掌控着计算的每一次脉动。</p>
<p>我是 qmwneb946，感谢你的阅读！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/qmwneb946">qmwneb946</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qmwneb946.dpdns.org/2025/07/24/2025-07-24-215527/">https://qmwneb946.dpdns.org/2025/07/24/2025-07-24-215527/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a> 许可协议。转载请注明来源 <a href="https://qmwneb946.dpdns.org" target="_blank">qmwneb946 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/Linux%E5%86%85%E6%A0%B8%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8/">Linux内核的调度器</a></div><div class="post-share"><div class="social-share" data-image="/img/icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/24/2025-07-24-221200/" title="少样本学习的度量学习方法：当数据稀缺时，如何让模型“学会比较”"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">少样本学习的度量学习方法：当数据稀缺时，如何让模型“学会比较”</div></div><div class="info-2"><div class="info-item-1">大家好，我是你们的老朋友 qmwneb946，一个对技术和数学充满热情的博主。今天，我们将深入探讨一个在人工智能领域日益重要的话题：少样本学习（Few-Shot Learning, FSL）中的度量学习方法。 我们生活在一个数据爆炸的时代，深度学习的成功很大程度上依赖于海量标注数据的支撑。然而，在许多真实世界场景中，获取大量高质量的标注数据是极其昂贵、耗时甚至不可能的。例如，在医疗影像诊断中识别罕见疾病、在机器人学中学习新的物体操作，或者在个性化推荐系统中适应用户瞬息万变的新兴趣点——这些任务往往只能提供极少的样本。 传统的深度学习模型在数据稀缺时往往会遭遇“过拟合”的困境，泛化能力直线下降。这就是少样本学习应运而生并备受关注的原因：它旨在让模型具备从少量甚至一个样本中学习并泛化到新类别的能力，就像人类一样。 那么，在这种数据极度匮乏的情况下，我们如何才能让机器高效地学习呢？一个极具启发性的思路是：与其直接学习复杂的分类边界，不如让模型学会如何“比较”样本之间的相似性。 这正是度量学习（Metric Learning）的核心思想。它试图学习一个有效的特征空间，使得相似的样本在这个...</div></div></div></a><a class="pagination-related" href="/2025/07/24/2025-07-24-215416/" title="深入剖析分布式数据库的事务处理：在混沌中寻求一致与可靠"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">深入剖析分布式数据库的事务处理：在混沌中寻求一致与可靠</div></div><div class="info-2"><div class="info-item-1">你好，我是 qmwneb946，一名对技术和数学充满热情的博主。今天，我们将一同踏上一段深度的技术之旅，探索一个在分布式系统领域既充满挑战又至关重要的主题——“分布式数据库的事务处理”。 在当今数据爆炸和服务高度并行的时代，单体数据库已无法满足海量数据存储和高并发访问的需求。分布式数据库应运而生，它将数据分散存储在多台计算机上，以提供卓越的扩展性、可用性和容错能力。然而，这种分布式的特性也带来了一个核心难题：如何在跨多个独立节点的复杂环境中，保障数据操作的原子性、一致性、隔离性和持久性（即 ACID 特性）？这正是分布式事务处理的核心任务。 我们将从事务处理的基石——ACID 特性出发，深入探讨在分布式环境下维护这些特性的固有挑战。随后，我们将揭开经典分布式事务协议的神秘面纱，如两阶段提交（2PC）和三阶段提交（3PC），剖析它们的原理、优缺点和适用场景。更进一步，我们将触及现代分布式系统如何演进，通过更灵活、更适应云原生环境的模式来应对分布式事务的挑战，包括 Saga 模式、事务性发件箱模式以及新型数据库（NewSQL）的设计哲学。 准备好了吗？让我们一头扎进分布式数据库事务处...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/18/2025-07-18-082448/" title="数据挖掘在金融风控的应用：从算法到实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">数据挖掘在金融风控的应用：从算法到实践</div></div><div class="info-2"><div class="info-item-1">大家好，我是你们的技术博主，今天我们来深入探讨一个与我们日常生活息息相关，却又充满技术挑战的领域：金融风控。在这个领域中，数据挖掘技术发挥着越来越重要的作用，它帮助金融机构有效识别和管理风险，保障金融体系的稳定运行。本文将从多个角度深入探讨数据挖掘在金融风控中的应用，并结合实际案例进行分析。 数据挖掘在金融风控中的关键作用 金融风控的目标是识别、评估和控制各种金融风险，例如信用风险、欺诈风险、操作风险等。传统的风控方法往往依赖于人工审核和简单的统计模型，效率低、准确率不高。而数据挖掘技术的出现，为金融风控带来了革命性的变革。它能够从海量数据中提取有价值的信息，建立更精确的风险模型，从而提高风控效率和准确性。 具体来说，数据挖掘在金融风控中主要发挥以下作用： 欺诈检测 欺诈行为日益猖獗，给金融机构造成巨大的经济损失。数据挖掘技术，特别是异常检测算法，能够有效识别出可疑交易行为。例如，基于机器学习的异常检测模型可以学习正常交易的模式，然后识别偏离该模式的异常交易，从而有效识别潜在的欺诈行为。常用的算法包括：  孤立森林 (Isolation Forest): 通过随机分割数据来隔离异...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082509/" title="虚拟现实技术的沉浸式体验：从感知到认知"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">虚拟现实技术的沉浸式体验：从感知到认知</div></div><div class="info-2"><div class="info-item-1">虚拟现实（VR）技术不再是科幻小说中的幻想，它已经逐渐融入我们的生活，并正在深刻地改变着我们与世界互动的方式。本文将深入探讨VR技术的沉浸式体验，从技术原理到感知机制，再到其潜在的应用和未来发展方向，为技术爱好者提供一个全面的视角。 沉浸式体验的奥秘：技术层面 VR技术能够创造出令人信服的沉浸式体验，这依赖于多项关键技术的协同作用。 显示技术与图像渲染 高质量的图像渲染是VR体验的关键。高分辨率、高刷新率的显示器能够有效减少画面延迟和模糊感，提升视觉舒适度。目前主流的VR头显大多采用OLED或LCD屏幕，并通过透镜系统将图像投射到用户的视网膜上，模拟真实世界的视觉体验。  为了实现更广阔的视野（FOV），厂商们也在不断改进透镜设计和显示面板技术。 空间音频技术 除了视觉，听觉在构建沉浸式环境中也扮演着至关重要的角色。空间音频技术通过模拟声音在三维空间中的传播，让用户能够准确感知声音的方位和距离，增强临场感。例如，头部追踪技术配合精密的算法，可以根据用户头部姿态实时调整声音的输出，使声音效果更加逼真。 追踪技术与交互方式 精确的追踪技术是VR体验流畅的关键。目前常用的追踪技术包括：...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082730/" title="有机合成中的手性催化技术：构建分子世界的精巧艺术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">有机合成中的手性催化技术：构建分子世界的精巧艺术</div></div><div class="info-2"><div class="info-item-1">有机合成，这门将简单的化学物质转化为复杂分子的艺术，正因手性分子的存在而变得更加精妙和挑战性。手性分子如同左右手一样，结构互为镜像，但性质却可能大相径庭。在药物研发、材料科学等领域，获得特定手性的分子至关重要，而手性催化技术正是实现这一目标的关键。本文将深入探讨有机合成中的手性催化技术，揭示其背后的原理和应用。 手性与手性催化：从镜像到精准控制 手性，源于希腊语“cheir”（手），指的是分子不能与其镜像重合的特性。这种结构差异导致手性分子具有不同的物理性质和生物活性。例如，一种药物的左旋体可能具有疗效，而其右旋体则可能无效甚至有害。因此，精准控制手性合成至关重要。 手性催化技术利用手性催化剂来控制反应的立体选择性，即优先生成特定手性的产物。催化剂本身是手性的，它通过与反应物形成短暂的超分子复合物，影响反应路径，从而引导反应朝特定立体异构体方向进行。这就好比一个熟练的工匠，用巧妙的手法引导反应物“组装”成预期的分子结构。 手性催化剂的类型及作用机制 目前，广泛应用的手性催化剂主要包括： 过渡金属配合物催化剂 这类催化剂通常含有手性配体与过渡金属中心（如铑、钌、钯等）结合而成。配体...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082852/" title="光谱分析技术在环境监测的应用：从原理到实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">光谱分析技术在环境监测的应用：从原理到实践</div></div><div class="info-2"><div class="info-item-1">大家好，我是你们的技术博主 DataWhisperer！今天我们来聊一个既高大上又贴近生活的技术领域：光谱分析技术在环境监测中的应用。  这可不是简单的“看看颜色”就能搞定的，它背后蕴含着丰富的物理学、化学和数学原理，并且在保护我们的环境方面发挥着越来越重要的作用。 引言：光谱分析 – 环境监测的“火眼金睛” 环境监测的目标是及时、准确地获取环境污染物的信息，为环境保护和管理提供科学依据。传统监测方法往往费时费力，且灵敏度有限。而光谱分析技术，凭借其快速、灵敏、多组分同时检测等优点，成为了环境监测领域的一匹黑马。  它利用物质与电磁辐射相互作用的特性，分析物质的成分和结构，从而实现对环境污染物的精准识别和定量分析。 光谱分析技术的种类及原理 光谱分析技术涵盖多种方法，根据所用电磁波的波长范围不同，可以分为： 紫外-可见光谱法 (UV-Vis) UV-Vis 光谱法利用物质对紫外和可见光区域电磁波的吸收特性进行分析。  不同物质具有独特的吸收光谱，通过测量吸收光谱的特征峰，可以确定物质的种类和浓度。  这在水质监测中应用广泛，例如检测重金属离子、有机污染物等。  其原理基于朗伯-比...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082903/" title="计算化学模拟分子间相互作用：从经典力场到量子力学"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">计算化学模拟分子间相互作用：从经典力场到量子力学</div></div><div class="info-2"><div class="info-item-1">引言 分子间相互作用是化学和生物学领域的核心概念，它支配着物质的物理和化学性质，例如溶解度、沸点、蛋白质折叠等等。精确地模拟这些相互作用对于理解和预测分子行为至关重要。计算化学为我们提供了一套强大的工具来研究分子间相互作用，从经典的力场方法到复杂的量子力学计算，本文将深入探讨这些方法及其应用。 经典力场方法 经典力场方法基于牛顿力学，将分子简化为一系列原子，并通过经验参数化的势能函数来描述原子间的相互作用。这种方法计算效率高，适用于模拟大量的原子和分子，例如蛋白质、DNA和材料科学中的大分子体系。 势能函数 经典力场通常包含以下几种类型的相互作用项：  键伸缩 (Bond Stretching): 描述键长偏离平衡键长的能量变化，通常用谐振势能函数表示：Ebond=12kb(r−r0)2E_{bond} = \frac{1}{2}k_b(r - r_0)^2Ebond​=21​kb​(r−r0​)2，其中 kbk_bkb​ 是力常数，rrr 是键长，r0r_0r0​ 是平衡键长。 键角弯曲 (Angle Bending): 描述键角偏离平衡键角的能量变化，通常也用谐振势能函数表示...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082912/" title="绿色化学与可持续发展目标：技术与未来的融合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">绿色化学与可持续发展目标：技术与未来的融合</div></div><div class="info-2"><div class="info-item-1">近年来，可持续发展已成为全球关注的焦点，联合国提出的17个可持续发展目标 (SDGs) 为全球共同努力提供了蓝图。其中，许多目标都与化学工业息息相关，而绿色化学作为一种旨在减少或消除有害物质使用的化学方法，扮演着至关重要的角色。本文将探讨绿色化学如何为实现可持续发展目标做出贡献，并从技术角度深入分析其应用。 绿色化学的十二原则：通向可持续未来的基石 绿色化学的核心是其十二项原则，这些原则指导着化学家的研究和工业生产，力求最大限度地减少环境影响。这些原则并非相互独立，而是相互关联，共同构成了一个整体的框架。 预防原则 这是绿色化学的首要原则，强调在化学反应的设计阶段就应避免产生有害物质，而非在产生后进行处理。这需要化学家们从根本上重新思考化学反应的设计和工艺流程。 原子经济性 理想情况下，所有反应物原子都应转化为最终产物，没有任何浪费。原子经济性是衡量化学反应效率的重要指标，其计算公式为： 原子经济性=目标产物的分子量所有反应物的分子量总和×100%原子经济性 = \frac{目标产物的分子量}{所有反应物的分子量总和} \times 100\%原子经济性=所有反应物的分子量总和目...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">qmwneb946</div><div class="author-info-description">一个专注于技术分享的个人博客，涵盖编程、算法、系统设计等内容</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1337</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1341</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qmwneb946"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/qmwneb946" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:qmwneb946@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">代码与远方，技术与生活交织的篇章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80%EF%BC%9A%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8C%87%E6%8C%A5%E5%AE%B6"><span class="toc-number">1.</span> <span class="toc-text">引言：计算的指挥家</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8C%91%E6%88%98"><span class="toc-number">2.</span> <span class="toc-text">第一章：调度器的核心概念与挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%EF%BC%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-number">2.1.</span> <span class="toc-text">进程与线程：调度的基本单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E8%B0%83%E5%BA%A6%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">2.2.</span> <span class="toc-text">CPU 调度的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">2.3.</span> <span class="toc-text">抢占式调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2-Context-Switching"><span class="toc-number">2.4.</span> <span class="toc-text">上下文切换 (Context Switching)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.5.</span> <span class="toc-text">调度策略与优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9ALinux-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2%E6%BC%94%E8%BF%9B"><span class="toc-number">3.</span> <span class="toc-text">第二章：Linux 调度器的历史演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%80%8C%E7%9B%B4%E6%8E%A5"><span class="toc-number">3.1.</span> <span class="toc-text">早期调度器：朴素而直接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-1-%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9A%84%E9%A3%9E%E8%B7%83"><span class="toc-number">3.2.</span> <span class="toc-text">O(1) 调度器：性能的飞跃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%E5%99%A8-CFS-Completely-Fair-Scheduler-%EF%BC%9A%E5%85%AC%E5%B9%B3%E7%9A%84%E9%9D%A9%E5%91%BD"><span class="toc-number">3.3.</span> <span class="toc-text">完全公平调度器 (CFS - Completely Fair Scheduler)：公平的革命</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9ACFS%EF%BC%9A%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">第三章：CFS：完全公平的艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CFS-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">CFS 的核心数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-sched-entity%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BD%93"><span class="toc-number">4.1.1.</span> <span class="toc-text">struct sched_entity：调度实体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-cfs-rq%EF%BC%9ACFS-%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97"><span class="toc-number">4.1.2.</span> <span class="toc-text">struct cfs_rq：CFS 运行队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-Red-Black-Tree"><span class="toc-number">4.1.3.</span> <span class="toc-text">红黑树 (Red-Black Tree)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vruntime-%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%9A%E5%85%AC%E5%B9%B3%E7%9A%84%E9%87%8F%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">vruntime 的计算：公平的量化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8A%A0%E6%9D%83"><span class="toc-number">4.2.1.</span> <span class="toc-text">基本原理与加权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%91%A8%E6%9C%9F-Scheduler-Period-%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%B2%92%E5%BA%A6-Minimum-Granularity"><span class="toc-number">4.2.2.</span> <span class="toc-text">调度周期 (Scheduler Period) 与最小粒度 (Minimum Granularity)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.</span> <span class="toc-text">任务的选择与调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E8%B0%83%E5%BA%A6-Group-Scheduling"><span class="toc-number">4.4.</span> <span class="toc-text">组调度 (Group Scheduling)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%9A%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4%E5%93%8D%E5%BA%94"><span class="toc-number">5.</span> <span class="toc-text">第四章：实时调度器：追求极致响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">实时任务的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.</span> <span class="toc-text">Linux 实时调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E8%BF%90%E4%BD%9C"><span class="toc-number">5.3.</span> <span class="toc-text">实时调度器的运作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%AA%E6%AD%A2%E6%9C%9F%E8%B0%83%E5%BA%A6%E5%99%A8-SCHED-DEADLINE"><span class="toc-number">5.4.</span> <span class="toc-text">截止期调度器 (SCHED_DEADLINE)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B1%BB%E4%B8%8E%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">6.</span> <span class="toc-text">第五章：调度器类与协同工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-sched-class"><span class="toc-number">6.1.</span> <span class="toc-text">调度器类层次结构 (sched_class)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">6.2.</span> <span class="toc-text">中断上下文中的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%B0%83%E5%BA%A6%E5%99%A8-SCHED-IDLE"><span class="toc-number">6.3.</span> <span class="toc-text">空闲调度器 (SCHED_IDLE)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%A4%E9%86%92-Wakeup-%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%B0%83%E5%BA%A6"><span class="toc-number">6.4.</span> <span class="toc-text">唤醒 (Wakeup) 机制与调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E6%8B%93%E6%89%91%E6%84%9F%E7%9F%A5%E8%B0%83%E5%BA%A6%EF%BC%9ANUMA-%E4%B8%8E-SMP"><span class="toc-number">6.5.</span> <span class="toc-text">CPU 拓扑感知调度：NUMA 与 SMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%B0%83%E5%BA%A6%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">7.</span> <span class="toc-text">第六章：调度器性能优化与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98-sysctl"><span class="toc-number">7.1.</span> <span class="toc-text">调度器参数调优 (sysctl)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#perf-%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%88%A9%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">perf 工具：性能分析利器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ftrace-%E8%B7%9F%E8%B8%AA%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%86%85%E6%A0%B8%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.3.</span> <span class="toc-text">ftrace 跟踪：深入内核事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="toc-number">7.4.</span> <span class="toc-text">调试技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A%E6%8E%8C%E6%8E%A7%E8%AE%A1%E7%AE%97%E7%9A%84%E8%84%89%E6%90%8F"><span class="toc-number">8.</span> <span class="toc-text">结论：掌控计算的脉搏</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/hello-world/" title="Hello World">Hello World</a><time datetime="2025-07-26T06:59:51.413Z" title="发表于 2025-07-26 14:59:51">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="博弈论基础">博弈论基础</a><time datetime="2025-07-26T06:59:51.413Z" title="发表于 2025-07-26 14:59:51">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/2025-07-26-065654/" title="解锁超分子聚合物的力学奥秘：从微观作用到宏观性能的深度探索">解锁超分子聚合物的力学奥秘：从微观作用到宏观性能的深度探索</a><time datetime="2025-07-25T22:56:54.000Z" title="发表于 2025-07-26 06:56:54">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/2025-07-26-065552/" title="柔性电子器件的稳定性：从材料到应用的全景深度剖析">柔性电子器件的稳定性：从材料到应用的全景深度剖析</a><time datetime="2025-07-25T22:55:52.000Z" title="发表于 2025-07-26 06:55:52">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/2025-07-26-065438/" title="计算辅助的蛋白质相互作用预测：揭示生命奥秘的智能钥匙">计算辅助的蛋白质相互作用预测：揭示生命奥秘的智能钥匙</a><time datetime="2025-07-25T22:54:38.000Z" title="发表于 2025-07-26 06:54:38">2025-07-26</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By qmwneb946</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'qmwneb946/blog',
      'data-repo-id': 'R_kgDOPM6cWw',
      'data-category-id': 'DIC_kwDOPM6cW84CtEzo',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>