<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>窥探细胞的微观战场：单细胞基因组中的拷贝数变异及其解析 | qmwneb946 的博客</title><meta name="author" content="qmwneb946"><meta name="copyright" content="qmwneb946"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="你好，各位技术爱好者、生物信息学探险家们！我是你们的老朋友 qmwneb946。今天，我们要潜入一个令人兴奋且充满挑战的领域——单细胞基因组学，并聚焦于其中一个核心且极具生物学意义的现象：拷贝数变异 (CNV)。 想象一下，我们身体中的每一个细胞，都承载着一套完整的基因组信息。在传统的“批量”测序时代，我们就像在看一个城市的鸟瞰图，只能看到平均的、混杂的信号。而单细胞基因组学，则赋予了我们前所未">
<meta property="og:type" content="article">
<meta property="og:title" content="窥探细胞的微观战场：单细胞基因组中的拷贝数变异及其解析">
<meta property="og:url" content="https://qmwneb946.dpdns.org/2025/07/24/2025-07-25-000355/index.html">
<meta property="og:site_name" content="qmwneb946 的博客">
<meta property="og:description" content="你好，各位技术爱好者、生物信息学探险家们！我是你们的老朋友 qmwneb946。今天，我们要潜入一个令人兴奋且充满挑战的领域——单细胞基因组学，并聚焦于其中一个核心且极具生物学意义的现象：拷贝数变异 (CNV)。 想象一下，我们身体中的每一个细胞，都承载着一套完整的基因组信息。在传统的“批量”测序时代，我们就像在看一个城市的鸟瞰图，只能看到平均的、混杂的信号。而单细胞基因组学，则赋予了我们前所未">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qmwneb946.dpdns.org/img/icon.png">
<meta property="article:published_time" content="2025-07-24T16:03:55.000Z">
<meta property="article:modified_time" content="2025-07-26T07:43:24.656Z">
<meta property="article:author" content="qmwneb946">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="数学">
<meta property="article:tag" content="单细胞基因组的拷贝数变异">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qmwneb946.dpdns.org/img/icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "窥探细胞的微观战场：单细胞基因组中的拷贝数变异及其解析",
  "url": "https://qmwneb946.dpdns.org/2025/07/24/2025-07-25-000355/",
  "image": "https://qmwneb946.dpdns.org/img/icon.png",
  "datePublished": "2025-07-24T16:03:55.000Z",
  "dateModified": "2025-07-26T07:43:24.656Z",
  "author": [
    {
      "@type": "Person",
      "name": "qmwneb946",
      "url": "https://github.com/qmwneb946"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qmwneb946.dpdns.org/2025/07/24/2025-07-25-000355/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '窥探细胞的微观战场：单细胞基因组中的拷贝数变异及其解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2845632165165414" crossorigin="anonymous"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="qmwneb946 的博客" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">qmwneb946 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">窥探细胞的微观战场：单细胞基因组中的拷贝数变异及其解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">窥探细胞的微观战场：单细胞基因组中的拷贝数变异及其解析<a class="post-edit-link" href="https://github.com/qmwneb946/blog/edit/main/source/_posts/2025-07-25-000355.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-24T16:03:55.000Z" title="发表于 2025-07-25 00:03:55">2025-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-26T07:43:24.656Z" title="更新于 2025-07-26 15:43:24">2025-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><hr>
<p>你好，各位技术爱好者、生物信息学探险家们！我是你们的老朋友 qmwneb946。今天，我们要潜入一个令人兴奋且充满挑战的领域——单细胞基因组学，并聚焦于其中一个核心且极具生物学意义的现象：拷贝数变异 (CNV)。</p>
<p>想象一下，我们身体中的每一个细胞，都承载着一套完整的基因组信息。在传统的“批量”测序时代，我们就像在看一个城市的鸟瞰图，只能看到平均的、混杂的信号。而单细胞基因组学，则赋予了我们前所未有的能力，将镜头推到每一栋“建筑”前，看清每一个“居民”的独特面貌。在这场微观的探索中，拷贝数变异扮演着至关重要的角色，它们是基因组结构变化的“指纹”，揭示着细胞的命运、疾病的发生与演进，甚至生命的奥秘。</p>
<p>拷贝数变异，简单来说，就是基因组中特定 DNA 片段的重复（扩增）或缺失。这些看似微小的变化，却能对细胞功能产生深远影响。在单细胞层面研究 CNV，更是打开了一扇窗，让我们得以解析细胞异质性、追踪克隆演化、理解复杂疾病（尤其是癌症）的起源和进展。然而，单细胞数据固有的高噪音、低覆盖度和技术偏差，也使得 scCNV（单细胞拷贝数变异）的检测成为一项充满挑战的艺术与科学。</p>
<p>本篇博客，我将带领大家踏上一段深度解析之旅，从 CNV 的基础概念出发，逐步深入到单细胞测序的技术原理、scCNV 的各种检测方法（包括其背后的数学模型和统计学原理）、面临的挑战、在生物医学研究中的广泛应用，以及未来的发展方向。这不仅仅是一篇技术文章，更是一次对生命奥秘的探索，对数据科学与生物学交叉融合之美的赞叹。准备好了吗？让我们一起，揭开单细胞基因组中拷贝数变异的神秘面纱！</p>
<h2 id="基因组的动态舞者：拷贝数变异-CNV-基础">基因组的动态舞者：拷贝数变异 (CNV) 基础</h2>
<p>在深入探讨单细胞层面之前，我们首先需要对拷贝数变异（Copy Number Variation, CNV）有一个清晰而全面的理解。它们是基因组中广泛存在的一种结构变异，是构成人类基因组多样性的重要组成部分，也是诸多复杂疾病，特别是癌症发生发展中的关键驱动力。</p>
<h3 id="什么是拷贝数变异？">什么是拷贝数变异？</h3>
<p>从最基本的定义来看，拷贝数变异是指基因组中大于 1 千碱基 (kb) 的 DNA 片段的重复（扩增）或缺失。根据最新的定义，CNV 可以包括从几百个碱基对到几兆个碱基对的变异。在正常二倍体人类细胞中，每个常染色体区域通常有两份拷贝，分别来自父母。当某个区域的拷贝数不等于 2 时，我们称之为拷贝数变异。</p>
<p>CNV 的类型主要包括：</p>
<ul>
<li><strong>缺失 (Deletion):</strong> 基因组中的一个区域完全丢失，导致拷贝数小于 2（例如，如果一个区域完全缺失，则拷贝数为 0 或 1）。</li>
<li><strong>重复 (Duplication):</strong> 基因组中的一个区域被复制一次或多次，导致拷贝数大于 2（例如，拷贝数为 3 或更多）。</li>
<li><strong>扩增 (Amplification):</strong> 特指某一基因或区域发生高度重复，导致拷贝数显著增加，通常与癌症中的致癌基因激活相关。</li>
<li><strong>非整倍体 (Aneuploidy):</strong> 染色体数量的整体或部分异常，例如唐氏综合征（21 号染色体三体），这可以被视为特定染色体或染色体臂的大尺度 CNV。</li>
</ul>
<p>这些变异可以是“获得性”的，即在个体生命过程中（如肿瘤发生）新出现的；也可以是“遗传性”的，即从亲代遗传而来，并在群体中普遍存在，作为遗传多样性的一部分。</p>
<h3 id="CNV-的生物学意义">CNV 的生物学意义</h3>
<p>拷贝数变异并非仅仅是基因组的“错误”，它们在生物学中扮演着多重角色，有些是良性的，有些则与疾病密切相关。</p>
<h4 id="1-正常生理功能与个体多样性">1. 正常生理功能与个体多样性</h4>
<p>CNV 是人类基因组多样性的重要来源之一，它解释了人与人之间表型差异的很大一部分。一些 CNV 位于非编码区，可能对表型影响不大；而另一些则可能影响基因表达水平，进而影响个体对环境的适应、药物的反应，甚至是对疾病的易感性。例如，某些免疫相关基因（如趋化因子受体 CCR5）的 CNV 就可以影响个体对 HIV 感染的抵抗力。通过 CNV，基因组能够以超越点突变和小型插入/缺失的方式进行快速演化，适应环境压力。</p>
<h4 id="2-复杂疾病的驱动因素">2. 复杂疾病的驱动因素</h4>
<p>CNV 与多种复杂疾病的发生发展密切相关。</p>
<ul>
<li><strong>神经发育障碍:</strong> 自闭症谱系障碍 (ASD)、精神分裂症、智力障碍等疾病中，经常发现与神经元功能相关的基因 CNV。这些 CNV 可能是致病的，也可能是疾病易感性的修饰因子。</li>
<li><strong>自身免疫性疾病:</strong> 某些 CNV 会影响免疫相关基因的拷贝数，进而改变免疫反应，增加自身免疫性疾病的风险，如系统性红斑狼疮、克罗恩病等。</li>
<li><strong>心血管疾病:</strong> 一些 CNV 被发现与高血压、冠心病等心血管疾病的风险相关。</li>
<li><strong>癌症:</strong> 这是 CNV 研究最为深入的领域之一。在癌症中，CNV 是普遍存在的基因组改变，扮演着“驱动突变”或“乘客突变”的角色。
<ul>
<li><strong>致癌基因扩增:</strong> 导致细胞增殖失控，例如 ERBB2（HER2）在乳腺癌中的扩增、MYC 在多种癌症中的扩增。</li>
<li><strong>抑癌基因缺失:</strong> 导致细胞周期检查点失灵、DNA 损伤修复缺陷，例如 TP53、RB1 等基因的缺失。</li>
<li><strong>基因组不稳定性:</strong> 大尺度 CNV 或染色体非整倍体是肿瘤基因组不稳定的标志，与肿瘤的恶性程度、转移和耐药性密切相关。癌细胞通过获得或丢失关键基因组区域来适应微环境、逃避免疫监视和抵抗治疗。</li>
</ul>
</li>
</ul>
<h3 id="传统-CNV-检测方法的局限性">传统 CNV 检测方法的局限性</h3>
<p>在单细胞测序技术兴起之前，CNV 的检测主要依赖于批量测序（bulk sequencing）和细胞遗传学方法。这些方法在理解 CNV 方面发挥了巨大作用，但也存在其固有的局限性。</p>
<h4 id="1-批量测序的“平均效应”">1. 批量测序的“平均效应”</h4>
<p>批量测序是对数百万个细胞（例如，从组织样本中提取的 DNA）进行整体测序。这种方法的根本局限在于其“平均效应”：</p>
<ul>
<li><strong>异质性掩盖:</strong> 组织样本往往是高度异质的，尤其是在肿瘤组织中，包含了肿瘤细胞、基质细胞、免疫细胞、内皮细胞等多种细胞类型。即使是肿瘤细胞内部，也存在着高度的克隆异质性。批量测序得到的是这些不同细胞类型基因组信号的加权平均。这意味着，如果只有一小部分细胞携带某种 CNV，其信号可能被大量不携带该 CNV 的细胞信号所稀释，导致难以检测到稀有克隆或早期事件。</li>
<li><strong>无法解析亚克隆结构:</strong> 批量测序无法区分是所有细胞都带有某种 CNV，还是只有一部分细胞（亚克隆）带有该 CNV。因此，它无法追踪肿瘤的克隆演化路径，也无法识别驱动肿瘤耐药性的稀有细胞亚群。</li>
<li><strong>早期或低丰度 CNV 难以捕捉:</strong> 在疾病早期或肿瘤进展的初期，携带致病性 CNV 的细胞可能数量极少，批量测序可能无法提供足够的检测灵敏度。</li>
</ul>
<h4 id="2-细胞遗传学方法的低分辨率">2. 细胞遗传学方法的低分辨率</h4>
<p>传统的细胞遗传学技术，如核型分析（Karyotyping）、荧光原位杂交 (FISH) 和比较基因组杂交 (CGH)，可以直接观察染色体或其片段的拷贝数变化：</p>
<ul>
<li><strong>核型分析:</strong> 可以检测到染色体的大尺度异常（如非整倍体、大的易位和缺失），但分辨率较低，通常只能检测到大于 5-10Mb 的变异。</li>
<li><strong>FISH:</strong> 针对特定的 DNA 探针进行检测，可以实现较高的局部分辨率，但每次只能检测少数几个区域。</li>
<li><strong>CGH/aCGH:</strong> 比较基因组杂交（或基于芯片的比较基因组杂交）通过比较患者和对照 DNA 的荧光强度来检测 CNV，分辨率高于核型分析，但仍受限于芯片探针的密度，且无法提供单细胞信息。</li>
</ul>
<p>这些方法在临床诊断中仍有重要地位，但对于精细的基因组结构变异，特别是那些发生在细胞亚群中的变异，它们就显得力不从心了。正是这些传统方法的局限性，催生了对更高分辨率、能够解析单细胞异质性技术的需求——单细胞基因组学应运而生。</p>
<h2 id="放大镜下的单细胞世界：单细胞基因组学概览">放大镜下的单细胞世界：单细胞基因组学概览</h2>
<p>随着测序技术和微流控技术的飞速发展，我们现在能够从单个细胞中获取基因组、转录组甚至表观基因组信息，这彻底改变了我们对细胞异质性的理解。</p>
<h3 id="为什么需要单细胞基因组学？">为什么需要单细胞基因组学？</h3>
<p>生命体是高度复杂的，其功能由无数个相互协作的细胞构成。即便在同一组织、同一类型的细胞中，也存在着显著的功能和状态差异。这种“异质性”是生物学的常态，而非例外。例如：</p>
<ul>
<li><strong>肿瘤异质性：</strong> 肿瘤并非由单一克隆组成，而是由具有不同遗传突变和表型的细胞亚群构成。这些亚群可能对治疗的反应不同，甚至导致耐药性的产生。</li>
<li><strong>发育过程：</strong> 在胚胎发育过程中，细胞通过分化产生不同的细胞类型，但即使是同一谱系的细胞，也可能处于不同的发育阶段或具有不同的转录组状态。</li>
<li><strong>免疫反应：</strong> 免疫细胞在面对病原体时会迅速分化并产生多种效应细胞，这些细胞在基因表达和功能上存在巨大差异。</li>
<li><strong>神经系统：</strong> 大脑中包含了上千种不同类型的神经元和胶质细胞，它们各自具有独特的形态、连接和功能。</li>
</ul>
<p>批量测序无法捕捉到这些细胞间的细微差别，它提供的是一个“平均”的快照，掩盖了重要的生物学信息。单细胞基因组学（Single-Cell Genomics, scG）的核心价值在于：<strong>它能够揭示细胞群体的异质性，识别稀有细胞类型，追踪细胞命运轨迹，并解析细胞状态转换过程中的分子事件。</strong> 对于 CNV 而言，scG 能够让我们在单细胞水平上识别拷贝数异常，进而追踪肿瘤克隆的演化，理解耐药性的遗传基础，甚至发现早期疾病的生物标志物。</p>
<h3 id="单细胞测序技术简介">单细胞测序技术简介</h3>
<p>单细胞测序技术根据所分析的分子类型，可以分为不同的类别：</p>
<h4 id="1-单细胞-DNA-测序-scDNA-seq">1. 单细胞 DNA 测序 (scDNA-seq)</h4>
<p>scDNA-seq 的目标是捕获单个细胞的全部基因组 DNA 信息，是直接检测单细胞 CNV 的主要手段。其基本流程包括：</p>
<ul>
<li><strong>单细胞分离：</strong> 这是所有单细胞测序技术的第一步，通过流式细胞术（FACS）、微流控芯片（如 10x Genomics Chromium、Drop-seq）、激光捕获显微切割 (LCM) 或手动挑取等方法，将单个细胞分离到独立微孔或液滴中。</li>
<li><strong>细胞裂解与 DNA 释放：</strong> 轻轻裂解细胞膜，释放基因组 DNA。</li>
<li><strong>全基因组扩增 (Whole Genome Amplification, WGA)：</strong> 由于单个细胞的 DNA 量极少（人类二倍体细胞约 6pg），不足以直接用于测序，因此需要进行 WGA。目前主流的 WGA 方法包括：
<ul>
<li><strong>多重置换扩增 (Multiple Displacement Amplification, MDA):</strong> 使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mn>29</mn></mrow><annotation encoding="application/x-tex">\phi 29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span><span class="mord">29</span></span></span></span> 聚合酶进行等温扩增，以随机引物起始，链置换合成，能产生高质量、长片段的 DNA 产物。是目前 scDNA-seq 中最常用的 WGA 方法。</li>
<li><strong>简并寡核苷酸引物 PCR (DOP-PCR):</strong> 使用随机引物进行 PCR 扩增。</li>
<li><strong>准线性扩增 (Quasi-Linear Amplification, QLA):</strong> 一种旨在减少扩增偏倚的新方法。</li>
</ul>
</li>
<li><strong>文库构建与测序：</strong> 扩增后的 DNA 产物用于构建测序文库，然后在高通量测序平台（如 Illumina NextSeq/NovaSeq）上进行测序。</li>
</ul>
<p><strong>常见的 scDNA-seq 测序策略：</strong></p>
<ul>
<li><strong>低深度全基因组测序 (low-pass WGS):</strong> 对每个细胞进行低覆盖度测序，通常在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.01</mn><mo>×</mo></mrow><annotation encoding="application/x-tex">0.01 \times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.01</span><span class="mord">×</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo></mrow><annotation encoding="application/x-tex">1 \times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord">×</span></span></span></span> 之间。虽然覆盖度低，但对于检测大的 CNV 和非整倍体已足够。这是目前最常用的 scCNV 检测方法，因为它具有成本效益，可以分析大量细胞。</li>
<li><strong>目标区域测序:</strong> 对预定义的目标区域进行高深度测序，适用于已知特定基因或区域存在 CNV 的情况。</li>
<li><strong>单细胞全外显子组测序 (scWES):</strong> 仅测序外显子区域，成本介于低深度 WGS 和高深度 WGS 之间，可以检测外显子区域的 CNV。</li>
</ul>
<h4 id="2-单细胞-RNA-测序-scRNA-seq">2. 单细胞 RNA 测序 (scRNA-seq)</h4>
<p>scRNA-seq 用于量化单个细胞内的基因表达水平。虽然不能直接检测 DNA 层面的 CNV，但研究表明，大的 CNV 区域通常会影响其所包含基因的表达量。因此，scRNA-seq 可以在一定程度上<strong>推断</strong>大尺度的 CNV，特别是染色体级别的非整倍体。其优势在于细胞通量高，成本相对较低，已成为目前最普及的单细胞测序技术。</p>
<h4 id="3-单细胞-ATAC-测序-scATAC-seq">3. 单细胞 ATAC 测序 (scATAC-seq)</h4>
<p>scATAC-seq 用于分析单个细胞的染色质可及性（chromatin accessibility），揭示基因组中开放染色质区域，通常与基因调控元件（如启动子、增强子）相关。与 scRNA-seq 类似，虽然不直接测序 DNA，但染色质可及性的变化也可能反映 CNV，因为缺失或扩增会改变染色质片段的相对丰度。</p>
<h3 id="单细胞-DNA-测序的挑战">单细胞 DNA 测序的挑战</h3>
<p>尽管 scDNA-seq 提供了前所未有的分辨率，但其固有的技术挑战也使其数据分析变得复杂。</p>
<h4 id="1-全基因组扩增-WGA-偏倚">1. 全基因组扩增 (WGA) 偏倚</h4>
<p>WGA 是 scDNA-seq 不可或缺的一步，但它并非完美无缺：</p>
<ul>
<li><strong>扩增偏倚 (Amplification Bias):</strong> WGA 过程会引入不同基因组区域的扩增效率差异，导致某些区域被过度扩增，而另一些区域扩增不足，从而产生不均匀的覆盖度。这使得基于测序深度的 CNV 检测变得困难，因为测序深度的变化可能是由于扩增偏倚，而非真实的拷贝数变化。</li>
<li><strong>等位基因丢失 (Allele Dropout, ADO):</strong> 随机引物在 DNA 链上结合的随机性，可能导致某一等位基因未被扩增，从而造成假性等位基因失衡 (Loss of Heterozygosity, LOH) 或假性 CNV。</li>
<li><strong>嵌合体 (Chimerism):</strong> 某些 WGA 方法可能产生嵌合体 DNA 分子，即来自不同基因组区域的 DNA 片段在扩增过程中被错误连接。</li>
<li><strong>引物二聚体和污染：</strong> 扩增过程中可能产生大量引物二聚体，或样本在实验过程中被外部 DNA 污染，进一步降低有效测序深度和数据质量。</li>
</ul>
<p>这些偏倚导致单细胞测序数据通常具有高噪音和不均匀性，对后续的 CNV 检测算法提出了更高的要求。</p>
<h4 id="2-低起始-DNA-量与覆盖度不足">2. 低起始 DNA 量与覆盖度不足</h4>
<p>单个细胞的 DNA 量极少，即使经过 WGA，最终用于测序的 DNA 量依然有限。这常常导致：</p>
<ul>
<li><strong>低测序深度:</strong> 为了平衡成本和通量，单个细胞的测序深度通常较低（尤其是低深度全基因组测序），这意味着很多基因组区域可能根本没有被测到（即“空洞”）。</li>
<li><strong>稀疏性:</strong> 低深度和不均匀的覆盖度导致数据稀疏，大量区域没有足够的测序读段来准确估计拷贝数。</li>
</ul>
<h4 id="3-假阳性和假阴性-CNV">3. 假阳性和假阴性 CNV</h4>
<p>由于上述技术挑战，scCNV 检测中存在较高的假阳性（将技术噪音误判为 CNV）和假阴性（未能检测到真实存在的 CNV）风险。区分真正的生物学信号和技术噪音是 scCNV 分析的核心挑战。</p>
<p>综上所述，单细胞基因组学，特别是 scDNA-seq，为我们解析细胞异质性 CNV 提供了强大的工具。然而，其独特的技术限制也要求我们在数据分析中采用更为精细和鲁棒的计算方法。</p>
<h2 id="单细胞拷贝数变异-scCNV-检测：理论与方法">单细胞拷贝数变异 (scCNV) 检测：理论与方法</h2>
<p>克服单细胞数据固有的挑战，准确识别 scCNV，是生物信息学领域的一大热点。目前，scCNV 的检测方法主要分为基于测序深度、基于等位基因，以及基于多模态数据推断这几大类。每种方法都有其适用场景、优缺点以及背后的数学原理。</p>
<h3 id="scCNV-检测的独特挑战">scCNV 检测的独特挑战</h3>
<p>在深入方法之前，再次强调 scCNV 检测面临的独特挑战：</p>
<ol>
<li><strong>高噪音和低信噪比：</strong> WGA 导致的扩增偏倚使得测序深度在基因组区域之间波动剧烈，且细胞之间也存在差异。</li>
<li><strong>数据稀疏性：</strong> 低深度测序导致许多基因组区域没有足够的读段来准确估计拷贝数。</li>
<li><strong>单细胞的固有异质性：</strong> 同一样本中的细胞可能处于不同的细胞周期阶段，或具有不同的倍性状态，这些都会影响背景拷贝数。</li>
<li><strong>区分技术假象与生物学信号：</strong> 如何在噪音背景下识别真正的 CNV 信号，是所有算法的核心目标。</li>
</ol>
<h3 id="基于深度的-scCNV-检测-Read-Depth-Based">基于深度的 scCNV 检测 (Read Depth Based)</h3>
<p>这是最直接也是最常用的 scCNV 检测方法，其核心思想是：<strong>基因组区域的拷贝数与其测序读段的覆盖度（即测序深度）成正比。</strong> 例如，如果某个区域的拷贝数是 4，那么其测序深度理论上应该是拷贝数为 2 的区域的两倍。</p>
<h4 id="原理">原理</h4>
<p>基本流程如下：</p>
<ol>
<li><strong>基因组分箱 (Binning):</strong> 将整个基因组划分为预定大小的非重叠的窗口（bin）。通常，bin 的大小在 10kb 到 1Mb 之间。选择合适的 bin 大小至关重要：太小会导致噪音过高，因为每个 bin 内的读段数太少；太大则会降低分辨率，错过小的 CNV。</li>
<li><strong>读段计数:</strong> 计算每个 bin 内比对到基因组的读段数量。</li>
<li><strong>标准化 (Normalization):</strong> 这是最关键的一步，旨在消除各种技术偏倚对测序深度的影响，使测序深度真正反映拷贝数。</li>
<li><strong>拷贝数估计与分段:</strong> 根据标准化后的测序深度，估计每个 bin 的拷贝数，并通过分段算法识别连续的、拷贝数发生变化的区域。</li>
</ol>
<h4 id="标准化">标准化</h4>
<p>标准化是基于深度方法成功与否的关键。常见的标准化策略包括：</p>
<ul>
<li><strong>GC 含量校正:</strong> 基因组不同区域的 GC 含量会影响 PCR 扩增效率和测序效率。通常通过回归模型校正 GC 含量对读段数的影响。假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 bin <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的原始读段数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">GC_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">G</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是其 GC 含量。我们可以建立一个模型来预测在无 CNV 情况下，给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">GC_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">G</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的期望读段数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><msub><mi>N</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E[N_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，然后用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>E</mi><mo stretchy="false">[</mo><msub><mi>N</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">N_i / E[N_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 进行校正。</li>
<li><strong>可比对性 (Mappability) 校正:</strong> 基因组中重复序列或低复杂性区域的 mappability 较低，导致读段难以唯一比对，从而降低测序深度。通常通过计算每个 bin 的可比对分数并进行相应校正。</li>
<li><strong>库大小校正 (Library Size Normalization):</strong> 不同细胞的总测序读段数可能差异很大（即库大小不同）。这通常通过将每个 bin 的读段数除以该细胞的总读段数（或中位数），然后乘以一个常数因子来实现，类似于 RPM（Reads Per Million）或 RPKM（Reads Per Kilobase Million）。<br>
例如，对于细胞 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 中的 bin <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，其标准化读段深度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 可以表示为：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mtext>Reads in bin </mtext><mi>i</mi><mtext> for cell </mtext><mi>j</mi></mrow><mrow><msub><mo>∑</mo><mrow><mtext>all bins </mtext><mi>k</mi></mrow></msub><mtext>Reads in bin </mtext><mi>k</mi><mtext> for cell </mtext><mi>j</mi></mrow></mfrac><mo>×</mo><mtext>Scaling Factor</mtext></mrow><annotation encoding="application/x-tex">D_{ij} = \frac{\text{Reads in bin } i \text{ for cell } j}{\sum_{\text{all bins } k} \text{Reads in bin } k \text{ for cell } j} \times \text{Scaling Factor}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5022em;vertical-align:-0.57em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1746em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">all bins </span></span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord text mtight"><span class="mord mtight">Reads in bin </span></span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord text mtight"><span class="mord mtight"> for cell </span></span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Reads in bin </span></span><span class="mord mathnormal mtight">i</span><span class="mord text mtight"><span class="mord mtight"> for cell </span></span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.57em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Scaling Factor</span></span></span></span></span></li>
<li><strong>细胞间标准化:</strong> 消除不同细胞之间（即使在经过库大小校正后）的系统性差异。这可以通过计算每个 bin 在所有细胞中的平均读段数，然后将每个细胞的读段数除以这个平均值来实现，或使用更复杂的基于聚类的归一化方法。例如，一些方法会识别“正常”细胞群体作为参考，然后将所有细胞的信号与这些正常细胞的平均信号进行比较。</li>
<li><strong>滑动窗口平滑 (Sliding Window Smoothing):</strong> 由于单个 bin 的读段数可能波动较大，通常会使用滑动窗口或核密度估计等方法对相邻 bin 的读段数进行平滑处理，以减少随机噪音。</li>
</ul>
<h4 id="分段算法">分段算法</h4>
<p>标准化并平滑后的读段深度曲线，可以视为一个时间序列信号。分段（Segmentation）的目标是识别出信号发生显著变化的“断点”或“改变点”（change-points），将基因组分成若干个具有相同拷贝数的连续区域。</p>
<ul>
<li><strong>隐马尔可夫模型 (Hidden Markov Model, HMM):</strong> HMM 是一种强大的统计模型，广泛应用于生物信息学中。在 CNV 检测中，HMM 假设基因组的每个 bin 处于一个“隐藏状态”（即真实拷贝数，如 0, 1, 2, 3, 4+），而我们观测到的是“发射概率”（即测序深度）。HMM 可以通过学习状态之间的转移概率和每个状态下的观测概率分布，来推断最可能的拷贝数序列。
<ul>
<li><strong>数学原理简述：</strong><br>
一个 HMM 由以下元素定义：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>q</mi><mi>N</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Q = \{q_1, \dots, q_N\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>: 隐藏状态集合 (e.g., <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mtext>MaxCopyNumber</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, 2, 3, \dots, \text{MaxCopyNumber}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">MaxCopyNumber</span></span><span class="mclose">}</span></span></span></span>)。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>v</mi><mi>M</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">V = \{v_1, \dots, v_M\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>: 观测符号集合 (e.g., 归一化后的读段深度值)。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>: 状态转移概率矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mi>t</mi></msub><mo>=</mo><mi>j</mi><mi mathvariant="normal">∣</mi><msub><mi>q</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A_{ij} = P(q_t = j | q_{t-1} = i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，表示从状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 转移到状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 的概率。通常假设 CNV 变化不会非常频繁，因此对相邻状态的转移概率较高，跨越多个状态的转移概率较低。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>: 观测概率矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>k</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>q</mi><mi>t</mi></msub><mo>=</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B_j(k) = P(v_k | q_t = j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，表示在隐藏状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 下观测到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的概率。这通常建模为某种概率分布，如高斯分布，其中每个拷贝数状态对应一个均值和方差。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>: 初始状态分布 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>i</mi></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_i = P(q_1 = i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>。<br>
给定观测序列（读段深度），Viterbi 算法可以找到最可能生成该序列的隐藏状态序列（即拷贝数序列）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>循环二元分割 (Circular Binary Segmentation, CBS):</strong> CBS 是一种非参数的分段算法，旨在识别信号中具有不同均值的连续区域。它通过迭代地在序列中寻找最佳分割点，使得分割后的两个子序列的均值差异最大。这种方法对噪音具有一定的鲁棒性。
<ul>
<li><strong>原理：</strong> 对于给定的序列，CBS 算法首先尝试寻找一个分割点，将序列分为两段，使得这两段的均值差异在统计上最显著。如果找到这样的分割点，则对这两段递归地重复此过程，直到无法找到显著的分割点为止。通常使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>-检验或 permutation 检验来评估均值差异的显著性。</li>
</ul>
</li>
<li><strong>惩罚似然估计 (PELT - Pruned Exact Linear Time):</strong> PELT 是一种高效的精确改变点检测算法，能够处理大规模数据集。它通过最小化一个包含数据拟合项和惩罚项（惩罚改变点的数量）的代价函数来识别改变点。
<ul>
<li><strong>数学原理：</strong> 假设我们有一个观测序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y_1, \dots, y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。目标是找到一组改变点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>τ</mi><mi>m</mi></msub><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0 &lt; \tau_1 &lt; \dots &lt; \tau_m &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，使得以下代价函数最小化：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></msubsup><mo stretchy="false">[</mo><mi mathvariant="script">C</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mrow><msub><mi>τ</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>y</mi><msub><mi>τ</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></msub><mo stretchy="false">)</mo><mo>+</mo><mi>β</mi><mo stretchy="false">]</mo><mo>+</mo><mi>K</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{j=0}^{m} [\mathcal{C}(y_{\tau_j+1}, \dots, y_{\tau_{j+1}}) + \beta] + K(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2401em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1132em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3473em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1132em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3473em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><br>
其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{C}(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> 是一个代价函数，通常是负对数似然（例如，对于高斯分布，是平方误差和）；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 是一个惩罚参数，用于控制改变点的数量（越大，改变点越少）；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 是另一个惩罚项，用于避免过拟合。PELT 算法通过动态规划和剪枝技术，高效地找到全局最优解。</li>
</ul>
</li>
</ul>
<h4 id="代表性工具">代表性工具</h4>
<ul>
<li><strong>Ginkgo:</strong> 一款流行的 R 包，专门用于单细胞拷贝数分析。它支持多种 WGA 方法的校正，并提供基于深度的 CNV 可视化和聚类功能。Ginkgo 使用一个复杂的归一化和分段流程来处理单细胞测序数据。</li>
<li><strong>SCOPE (Single-Cell ONCology PEnomic analysis):</strong> 一款针对癌症单细胞 CNV 检测的工具，它结合了 HMM 和基于滑动窗口的平滑技术，旨在提高在低深度数据下的检测准确性。</li>
<li><strong>CopyNumber (R包):</strong> 虽然不是专门为单细胞设计，但其核心的 CBS 算法是许多单细胞工具的基础。</li>
<li><strong>AneuFinder:</strong> 一个综合性的 R 包，能够检测染色体非整倍体和局部 CNV。它支持多种 WGA 方法的校正，并使用 HMM 进行分段。AneuFinder 还可以整合 GC 含量、Mappability 等信息进行校正。</li>
</ul>
<h3 id="基于等位基因的-scCNV-检测-Allele-Specific-Based">基于等位基因的 scCNV 检测 (Allele-Specific Based)</h3>
<p>除了测序深度，基因组中的单核苷酸多态性 (SNP) 位点也能提供 CNV 的信息，尤其对于检测 LOH（Loss of Heterozygosity，杂合性缺失）和非整倍体非常有用。</p>
<h4 id="原理-2">原理</h4>
<ul>
<li><strong>杂合性丢失 (LOH):</strong> 在正常二倍体细胞中，如果一个 SNP 位点是杂合的（即具有两个不同的等位基因，如 A/G），那么这两个等位基因的测序读段数应该大致相等（等位基因频率为 ~0.5）。如果发生某个染色体臂的缺失或单亲二体（Uniparental Disomy），则会导致 LOH，即只有一个等位基因被检测到，或某个等位基因的频率显著偏离 0.5。</li>
<li><strong>等位基因失衡 (Allelic Imbalance):</strong> 如果某个区域发生扩增，但扩增的拷贝数不是对称的（例如，一条染色体有 1 份，另一条染色体有 3 份），也会导致等位基因频率偏离 0.5。例如，一个 A/G 杂合位点，如果拷贝数为 AAG，那么 A 的频率为 2/3，G 的频率为 1/3。</li>
<li><strong>B 等位基因频率 (B-Allele Frequency, BAF):</strong> BAF 是一个特定 SNP 位点上非参考等位基因的比例。在正常二倍体区域，BAF 值通常聚类在 0、0.5 和 1 附近。CNV 会导致 BAF 值偏离 0.5，形成特征性的模式。</li>
<li><strong>对数 R 强度比 (Log R Ratio, LRR):</strong> LRR 是某个基因组区域在样本中的测序强度与参考强度之比的对数。LRR 结合 BAF 可以更准确地检测 CNV。</li>
</ul>
<h4 id="挑战">挑战</h4>
<ul>
<li><strong>对 SNP 覆盖度的要求高:</strong> 要准确估计等位基因频率，需要 SNP 位点有足够深的测序覆盖度，这在低深度单细胞测序中很难实现。</li>
<li><strong>等位基因丢失：</strong> WGA 导致的 ADO 可能会在没有真实 CNV 的情况下引起假性 LOH 信号。</li>
<li><strong>需要已知 SNP 位点信息：</strong> 需要预先知道或通过群体测序数据识别 SNP 位点。</li>
</ul>
<h4 id="工具">工具</h4>
<ul>
<li><strong>SCYN (Single-Cell Copy Number Analysis based on SNPs):</strong> 一些工具尝试结合深度和等位基因信息来提高 CNV 检测的准确性，但由于单细胞数据的稀疏性，纯粹基于等位基因的工具相对较少。</li>
<li><strong>AneuFinder (再次提及):</strong> 除了基于深度，AneuFinder 也可以利用 SNP 信息来辅助 CNV 检测，特别是识别非整倍体和 LOH。它会尝试将测序读段映射到已知的 SNP 位点，然后计算 BAF 模式。</li>
</ul>
<h3 id="多模态数据集成-Integrating-scRNA-seq-scATAC-seq-for-scCNV-Inference">多模态数据集成 (Integrating scRNA-seq/scATAC-seq for scCNV Inference)</h3>
<p>随着单细胞转录组（scRNA-seq）和单细胞染色质可及性（scATAC-seq）测序的普及，研究人员开始探索如何利用这些间接信息来推断 CNV，尤其是在没有直接 scDNA-seq 数据的情况下。</p>
<h4 id="原理-3">原理</h4>
<ul>
<li><strong>基因表达与拷贝数关系:</strong> 大尺度的 CNV（尤其是扩增和缺失）通常会直接影响其所包含基因的表达水平。例如，某个基因的扩增可能导致其 mRNA 表达量显著上调，而缺失则可能导致表达下调。</li>
<li><strong>染色质可及性与拷贝数关系:</strong> 同样，CNV 区域的染色质开放程度也可能受到影响。扩增可能导致该区域的开放程度增加，而缺失则可能减少。</li>
<li><strong>优势:</strong> scRNA-seq 和 scATAC-seq 的成本相对较低，细胞通量高，因此可以在大规模队列中进行 CNV 的初步筛选。</li>
</ul>
<h4 id="优点与局限">优点与局限</h4>
<ul>
<li><strong>优点:</strong>
<ul>
<li><strong>高通量:</strong> 可以分析更多的细胞，适合大规模研究。</li>
<li><strong>成本效益:</strong> 比 scDNA-seq 更便宜。</li>
<li><strong>提供额外信息:</strong> 与基因表达或染色质结构联系，有助于理解 CNV 的功能影响。</li>
</ul>
</li>
<li><strong>局限:</strong>
<ul>
<li><strong>间接推断:</strong> 无法直接检测 DNA 拷贝数，只能基于其对基因表达或染色质可及性的影响进行推断。</li>
<li><strong>分辨率有限:</strong> 只能推断大的 CNV 和非整倍体，对于小的、基因内的 CNV 难以检测。</li>
<li><strong>噪音源复杂:</strong> 基因表达受多种因素影响（如细胞周期、细胞类型、环境），使得从表达数据中分离出 CNV 信号更具挑战性。</li>
<li><strong>仅限于表达活跃或开放区域:</strong> 对于表达量极低或染色质紧密包装的区域，即使存在 CNV 也难以检测。</li>
</ul>
</li>
</ul>
<h4 id="代表性工具-2">代表性工具</h4>
<ul>
<li><strong>inferCNV:</strong> 最广泛使用的从 scRNA-seq 数据推断 CNV 的工具。其核心思想是，通过比较肿瘤细胞和（推定的）正常细胞在基因组连续区域的基因表达模式，来识别拷贝数变化。它将基因组划分为 bins，然后计算每个 bin 中基因的平均表达量，并通过与参考细胞的比较来识别异常区域。
<ul>
<li><strong>核心步骤：</strong>
<ol>
<li>识别参考细胞群（通常是正常细胞）。</li>
<li>对所有细胞的基因表达数据进行归一化。</li>
<li>将基因按基因组位置排序并分组到连续区域。</li>
<li>计算每个基因组区域在每个细胞中的平均表达强度。</li>
<li>将肿瘤细胞的表达强度与参考细胞的平均强度进行比较，通过差异表达模式推断 CNV。通常使用滑动平均、HMM 等技术来平滑和分段信号。</li>
</ol>
</li>
</ul>
</li>
<li><strong>CaSpER (Copy Number Variation Detection from Single Cell RNA-Seq Data):</strong> 另一个用于从 scRNA-seq 推断 CNV 的工具。它结合了表达强度和等位基因信息（如果有 SNP 信息），并使用多尺度分析和 HMM 来检测 CNV。</li>
<li><strong>copykat:</strong> 专注于从 scRNA-seq 推断肿瘤细胞的 CNV，并可以区分肿瘤细胞和正常细胞。它利用了一种基于机器学习的方法来识别 CNV 模式。</li>
</ul>
<h3 id="计算方法核心数学原理">计算方法核心数学原理</h3>
<p>无论基于何种数据类型，scCNV 检测的底层都离不开精密的数学和统计学方法。我们以基于读段深度的方法为例，深入探讨其中的几个核心数学概念。</p>
<h4 id="1-测序深度数据的统计建模">1. 测序深度数据的统计建模</h4>
<p>归一化后的测序深度通常被认为是服从某种统计分布。例如，在理想情况下，一个基因组区域的读段计数可以建模为泊松分布或负二项分布，这考虑到测序事件的随机性。</p>
<p>假设在基因组的某个 bin <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 中，我们观测到的读段数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。如果该 bin 的真实拷贝数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么我们期望观测到的读段数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E[k_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 应该与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 成正比。在校正了 GC 含量、Mappability 和库大小后，通常会将读段数转换成对数比值：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Log Ratio</mtext><mi>i</mi></msub><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mrow><mo fence="true">(</mo><mfrac><msub><mtext>Observed Reads</mtext><mi>i</mi></msub><mrow><msub><mtext>Expected Reads</mtext><mi>i</mi></msub><mtext> for normal copy number</mtext></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{Log Ratio}_i = \log_2 \left( \frac{\text{Observed Reads}_i}{\text{Expected Reads}_i \text{ for normal copy number}} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9275em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord text"><span class="mord">Log Ratio</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Expected Reads</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2052em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mord text mtight"><span class="mord mtight"> for normal copy number</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Observed Reads</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5311em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span><br>
对于一个二倍体区域，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>Log Ratio</mtext><mi>i</mi></msub><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{Log Ratio}_i \approx 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9275em;vertical-align:-0.2441em;"></span><span class="mord"><span class="mord text"><span class="mord">Log Ratio</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。缺失区域会得到负值，扩增区域会得到正值。</p>
<h4 id="2-隐马尔可夫模型-HMM-在分段中的应用">2. 隐马尔可夫模型 (HMM) 在分段中的应用</h4>
<p>HMM 在 CNV 检测中非常流行，因为它能够同时利用局部信息（每个 bin 的读段深度）和全局信息（相邻 bin 的拷贝数通常是连续的）。</p>
<ul>
<li><strong>状态定义:</strong> 隐藏状态通常是离散的拷贝数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>K</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S = \{0, 1, 2, 3, \dots, K\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">}</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 是最大可能的拷贝数。</li>
<li><strong>发射概率:</strong> 在给定某个隐藏拷贝数状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">s_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 时，观测到某个读段深度值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>k</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(v_k | s_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。通常，对于每个拷贝数状态，读段深度被建模为服从高斯分布：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>k</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>k</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>μ</mi><mi>j</mi></msub><mo separator="true">,</mo><msubsup><mi>σ</mi><mi>j</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(v_k | s_j) = \mathcal{N}(v_k | \mu_j, \sigma_j^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2089em;vertical-align:-0.3948em;"></span><span class="mord mathcal" style="margin-right:0.14736em;">N</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\mu_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 是拷贝数状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">s_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 对应的期望对数比值（例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>s</mi><mi>j</mi></msub><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log_2(s_j/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">/2</span><span class="mclose">)</span></span></span></span>），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>j</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma_j^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2089em;vertical-align:-0.3948em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span> 是该状态下的方差，反映噪音水平。</li>
<li><strong>转移概率:</strong> 从一个隐藏状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 转移到下一个隐藏状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">s_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 的概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo>=</mo><mi>j</mi><mi mathvariant="normal">∣</mi><msub><mi>s</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(s_t = j | s_{t-1} = i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>。这通常鼓励连续的、不变的拷贝数区域，并惩罚频繁的拷贝数变化。例如，对角线上的转移概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo>=</mo><mi>i</mi><mi mathvariant="normal">∣</mi><msub><mi>s</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(s_t=i | s_{t-1}=i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 很高，而非对角线上的概率很低。</li>
</ul>
<p>HMM 的训练（学习 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>j</mi></msub><mo separator="true">,</mo><msubsup><mi>σ</mi><mi>j</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\mu_j, \sigma_j^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2089em;vertical-align:-0.3948em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span> 和转移概率）通常使用 Baum-Welch 算法，而推断最可能的拷贝数序列则使用 Viterbi 算法。Viterbi 算法通过动态规划，高效地计算出最有可能的隐藏状态序列，从而实现基因组分段和拷贝数估计。</p>
<h4 id="3-改变点检测-Changepoint-Detection">3. 改变点检测 (Changepoint Detection)</h4>
<p>PELT 和 CBS 都属于改变点检测算法。它们不依赖于预设的拷贝数状态（如 HMM），而是直接在信号中寻找统计显著的变化点。</p>
<ul>
<li>
<p><strong>代价函数优化:</strong> 这类算法通常通过优化一个代价函数来识别改变点。代价函数通常包含两部分：</p>
<ol>
<li><strong>拟合优度项:</strong> 度量在给定分割点下，每个区段内数据与模型的匹配程度。例如，对于均值变化的检测，可以是每个区段内数据点到其均值的平方和。</li>
<li><strong>惩罚项:</strong> 惩罚改变点的数量。这有助于避免过拟合，选择更稀疏的改变点，从而获得更平滑、更具生物学意义的 CNV 区域。例如，BIC (Bayesian Information Criterion) 或 AIC (Akaike Information Criterion) 可以作为惩罚项。</li>
</ol>
<p>一个常见的代价函数形式是：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mi mathvariant="script">L</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mrow><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>y</mi><msub><mi>t</mi><mi>i</mi></msub></msub><mo stretchy="false">)</mo><mo>+</mo><mi>λ</mi><mo>⋅</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{m+1} \mathcal{L}(y_{t_{i-1}+1}, \dots, y_{t_i}) + \lambda \cdot m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2537em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2025em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2918em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span><br>
其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是观测数据（归一化后的读段深度），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">L</mi></mrow><annotation encoding="application/x-tex">\mathcal{L}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">L</span></span></span></span> 是损失函数（如负对数似然），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 是改变点的数量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> 是惩罚参数。</p>
</li>
</ul>
<p>这些算法通过高效的搜索策略（如动态规划）来最小化这个代价函数，从而找到最优的改变点位置。</p>
<p>理解这些底层数学和统计学原理，对于我们评估不同 scCNV 工具的性能、解读分析结果以及开发新的方法至关重要。它们是我们将噪音繁杂的单细胞数据转化为有生物学意义的 CNV 信息的基石。</p>
<h2 id="实践中的挑战与考量">实践中的挑战与考量</h2>
<p>尽管 scCNV 检测技术取得了显著进展，但在实际应用中，我们仍然面临诸多挑战。这些挑战不仅来自数据本身固有的复杂性，也源于分析流程中各种选择的相互作用。</p>
<h3 id="1-技术噪音与批次效应">1. 技术噪音与批次效应</h3>
<p>这是单细胞数据分析的“拦路虎”，对 CNV 检测影响尤为显著。</p>
<ul>
<li><strong>WGA 偏倚的异质性：</strong> 如前所述，WGA 过程会引入扩增偏倚，而这种偏倚在不同细胞、不同批次甚至不同实验室之间都可能存在显著差异。这意味着即使是正常细胞，其测序深度分布也可能波动，给 CNV 检测带来假阳性或假阴性。</li>
<li><strong>批次效应：</strong> 不同批次测序（例如，在不同日期、由不同操作员或使用不同试剂盒进行的实验）会导致系统性的非生物学变异。这些批次效应可能会掩盖真实的生物学信号，或引入伪影，使得跨批次比较变得困难。例如，某些批次的样本可能整体表现出略高的测序深度，这可能被误判为全局扩增。</li>
</ul>
<p><strong>应对策略：</strong> 严格的实验设计、内部对照（如正常细胞）的纳入、以及先进的批次效应校正算法（例如，基于线性混合模型、主成分分析 (PCA) 或更复杂的深度学习模型）是必要的。然而，完全消除技术噪音几乎是不可能的，关键在于最大限度地减少其影响，并让 CNV 检测算法对此具有鲁棒性。</p>
<h3 id="2-数据稀疏性与覆盖度">2. 数据稀疏性与覆盖度</h3>
<p>单细胞 DNA 测序，特别是低深度测序，会导致数据的高度稀疏性。</p>
<ul>
<li><strong>低覆盖度区域：</strong> 大量基因组区域可能根本没有被测到，或者只有极少的读段。这使得在这些区域估计拷贝数变得不可靠。</li>
<li><strong>小 CNV 检测困难：</strong> 如果一个 CNV 区域很小，且其内部的读段数不足，算法很难将其从背景噪音中区分出来。这限制了单细胞 CNV 检测的下游分辨率。</li>
<li><strong>假阴性风险：</strong> 即使存在真实的 CNV，由于覆盖度不足也可能被漏检。</li>
</ul>
<p><strong>应对策略：</strong> 选择合适的 bin 大小进行基因组分箱是关键。对于非常低深度的单细胞数据，可能需要更大的 bin 来确保每个 bin 中有足够的读段。此外，整合多个相邻 bin 的信息（例如通过滑动窗口平滑）有助于克服局部稀疏性。更直接的方法是增加测序深度，但这会显著提高成本。</p>
<h3 id="3-计算资源与可伸缩性">3. 计算资源与可伸缩性</h3>
<p>单细胞基因组学数据量巨大。一份典型的单细胞测序实验可能包含数百甚至数千个细胞，每个细胞都有其独特的基因组数据。</p>
<ul>
<li><strong>数据存储：</strong> 原始测序文件（FASTQ）、比对文件（BAM）和分析中间文件占用巨大的存储空间。</li>
<li><strong>计算时间：</strong> 从原始数据到最终 CNV 报告，涉及到比对、标准化、分箱、分段、聚类等多个计算密集型步骤。对数千个细胞进行全基因组 CNV 分析，可能需要数天甚至数周的计算时间。</li>
<li><strong>内存需求：</strong> 某些算法，尤其是涉及矩阵操作或图算法的，可能需要大量的内存。</li>
</ul>
<p><strong>应对策略：</strong> 利用高性能计算集群、云计算资源、开发并行化和内存高效的算法是必要的。许多流行的单细胞分析工具都支持并行计算，能够充分利用多核处理器。</p>
<h3 id="4-参考基因组与注释的准确性">4. 参考基因组与注释的准确性</h3>
<p>准确的 CNV 检测依赖于高质量的参考基因组和基因组注释信息。</p>
<ul>
<li><strong>参考基因组的局限性：</strong> 即使是人类参考基因组，也存在一些难以解析的区域（如高度重复区域、着丝粒、端粒），这些区域的可比对性较低，可能导致读段比对错误或缺失，从而引入假性 CNV。</li>
<li><strong>GC 含量、Mappability 图谱的准确性：</strong> 用于校正的 GC 含量和 mappability 图谱需要准确计算。不准确的校正可能无法有效去除技术偏倚。</li>
</ul>
<p><strong>应对策略：</strong> 使用最新版本的参考基因组和注释文件。对于高度重复区域，需要谨慎解读 CNV 信号。一些研究也开始探索无参考基因组的 CNV 检测方法，但目前仍处于早期阶段。</p>
<h3 id="5-生物学假阳性与假阴性">5. 生物学假阳性与假阴性</h3>
<p>区分真正的生物学信号和技术假象，以及在噪音中识别真实的 CNV，是一个持续的挑战。</p>
<ul>
<li><strong>正常细胞的背景 CNV：</strong> 即使是健康的个体，其体细胞中也可能存在少量体细胞 CNV，或某些区域天生具有拷贝数多态性 (Copy Number Polymorphism, CNP)。在肿瘤研究中，这些正常细胞中的 CNV 需要与肿瘤特异性 CNV 区分开。</li>
<li><strong>克隆异质性：</strong> 在肿瘤中，复杂的克隆演化和混合会使得 CNV 信号更加复杂。如何识别驱动克隆和乘客克隆的 CNV，需要结合多细胞分析和克隆谱系推断。</li>
<li><strong>细胞周期效应：</strong> 细胞在不同的细胞周期阶段（例如 S 期）其 DNA 拷贝数会有所变化，这可能被误认为是 CNV。一些工具会尝试校正细胞周期效应。</li>
<li><strong>低丰度亚克隆的检测：</strong> 对于在群体中占比极低的 CNV 亚克隆，即使是单细胞测序也可能面临挑战。</li>
</ul>
<p><strong>应对策略：</strong> 结合多种 CNV 检测方法进行交叉验证；利用已知正常细胞作为参考进行比较；整合其他单细胞组学数据（如 scRNA-seq），以相互印证 CNV 的功能影响；使用聚类和轨迹推断方法，将具有相似 CNV 模式的细胞聚集成克隆，并追踪其演化。</p>
<h3 id="6-肿瘤异质性与克隆演化">6. 肿瘤异质性与克隆演化</h3>
<p>在癌症研究中，单细胞 CNV 的最大价值在于解析肿瘤内部的异质性和克隆演化。然而，这也带来了额外的复杂性。</p>
<ul>
<li><strong>复杂克隆结构：</strong> 肿瘤内部可能存在多个亚克隆，它们携带不同的 CNV 组合，且不断演化。如何从海量单细胞 CNV 数据中重建出准确的克隆演化树，是一个复杂的计算问题。</li>
<li><strong>肿瘤微环境：</strong> 肿瘤样本通常混杂有正常细胞，如免疫细胞、内皮细胞和成纤维细胞。在 CNV 分析中，首先需要将肿瘤细胞与非肿瘤细胞区分开来，这通常通过 CNV 模式本身或结合其他分子标志物来完成。</li>
<li><strong>治疗压力下的克隆选择：</strong> 治疗可能导致特定 CNV 携带克隆的富集或清除，追踪这些动态变化对于理解耐药机制至关重要。</li>
</ul>
<p><strong>应对策略：</strong> 开发专门用于肿瘤异质性分析和克隆演化推断的算法，例如基于树结构的聚类方法，以及能够识别亚克隆特异性 CNV 的方法。结合长时间序列样本（如果可能）进行动态分析，以捕捉肿瘤演化的轨迹。</p>
<p>总而言之，单细胞 CNV 分析是一个多学科交叉的领域，需要生物学、统计学、计算机科学和工程学的紧密结合。虽然挑战重重，但正是这些挑战，驱动着方法学和技术的不断创新。</p>
<h2 id="scCNV-在生物医学研究中的应用">scCNV 在生物医学研究中的应用</h2>
<p>单细胞拷贝数变异分析的独特优势，使其在多个生物医学领域展现出巨大的应用潜力，特别是在解析细胞异质性、追踪疾病进展和发现新的生物标志物方面。</p>
<h3 id="1-肿瘤演化与耐药性">1. 肿瘤演化与耐药性</h3>
<p>这是 scCNV 最重要也是应用最广泛的领域。</p>
<ul>
<li><strong>解析肿瘤克隆异质性：</strong> 单细胞 CNV 能够清晰地描绘肿瘤内部的遗传多样性。每个肿瘤细胞的 CNV 图谱都像一个“指纹”，可以用来识别不同的肿瘤亚克隆。例如，在同一个肿瘤组织中，可能会发现主克隆、多个次级亚克隆以及一些正常基质细胞，它们各自带有独特的 CNV 特征。这有助于我们理解肿瘤的复杂性，并揭示哪些亚克隆可能具有更强的侵袭性或转移潜力。</li>
<li><strong>追踪肿瘤克隆演化路径：</strong> 通过对来自不同时间点（如原发肿瘤、复发肿瘤、转移灶）的单细胞进行 CNV 分析，可以重建肿瘤的克隆演化树。这使得研究人员能够识别在肿瘤进展、转移或治疗压力下被选择性富集的克隆，以及驱动这些克隆的 CNV 事件。例如，可以发现某些 CNV 是肿瘤起源的早期事件，而另一些则是在治疗后新获得的耐药性相关 CNV。</li>
<li><strong>识别耐药性相关的 CNV：</strong> 肿瘤在治疗过程中往往会产生耐药性，这常常与特定的 CNV 有关。通过比较治疗前和治疗后肿瘤细胞的 CNV，可以识别那些赋予细胞耐药性的扩增（如药物靶点基因扩增）或缺失（如抑癌基因缺失）。例如，EGFR 基因扩增在非小细胞肺癌中可能导致对 EGFR 抑制剂的耐药。</li>
<li><strong>指导个体化治疗：</strong> 识别肿瘤内部的耐药性亚克隆及其 CNV 驱动因素，可以为患者提供更精准的治疗方案，例如联合用药或靶向耐药性克隆的药物。</li>
<li><strong>液体活检中的应用：</strong> scCNV 分析也有望应用于循环肿瘤细胞 (CTC) 或循环肿瘤 DNA (ctDNA) 的研究，作为一种非侵入性的“液体活检”手段，实时监测肿瘤的演化和治疗响应。</li>
</ul>
<h3 id="2-发育生物学与神经科学">2. 发育生物学与神经科学</h3>
<p>scCNV 在非癌性疾病和生理过程中的应用也日益增加。</p>
<ul>
<li><strong>早期胚胎发育：</strong> 在早期胚胎发育过程中，细胞分裂和分化非常活跃。一些研究表明，早期胚胎细胞中可能存在低水平的非整倍体或 CNV。scCNV 可以帮助我们理解这些拷贝数变异是否是正常的发育过程，还是会导致发育缺陷或疾病。例如，在体外受精 (IVF) 的胚胎筛选中，scCNV 可能有助于识别具有异常拷贝数的胚胎。</li>
<li><strong>神经元多样性与脑疾病：</strong> 神经元细胞具有极高的异质性，并且在发育和衰老过程中可能积累体细胞突变和 CNV。scCNV 可以揭示不同神经元亚型中特异性的 CNV，以及这些 CNV 如何影响神经元功能，甚至导致神经退行性疾病（如阿尔茨海默病、帕金森病）或神经发育障碍（如自闭症）。例如，有研究发现，一些神经元在发育过程中会发生大的 CNV，这可能与它们的特化功能相关。</li>
<li><strong>细胞命运决定：</strong> CNV 可能影响关键发育基因的剂量效应，从而影响细胞的命运决定和分化路径。通过 scCNV，可以更精细地解析这些剂量效应。</li>
</ul>
<h3 id="3-自身免疫性疾病与感染">3. 自身免疫性疾病与感染</h3>
<ul>
<li><strong>免疫细胞中的 CNV：</strong> 免疫细胞在面对炎症或感染时会经历快速的克隆扩增和分化。scCNV 可以揭示特定免疫细胞亚群中获得的 CNV，这些 CNV 可能影响免疫反应的强度和持续时间，从而与自身免疫性疾病的发生发展相关。例如，某些免疫基因的扩增可能导致过度炎症反应。</li>
<li><strong>病原体感染：</strong> 在某些情况下，宿主细胞为了对抗病原体，可能会在基因组层面发生适应性 CNV。scCNV 有助于发现这些与感染抵抗力相关的基因组改变。</li>
</ul>
<h3 id="4-产前诊断与遗传咨询">4. 产前诊断与遗传咨询</h3>
<ul>
<li><strong>早期诊断：</strong> 传统的产前诊断（如羊水穿刺或绒毛膜取样后进行核型分析）通常使用批量细胞。scCNV 有潜力从更少量或更早期获取的胎儿细胞（如循环胎儿细胞）中检测 CNV，从而实现更早期的产前筛查，并提供更高分辨率的基因组信息。</li>
<li><strong>嵌合体检测：</strong> 在一些遗传疾病中，患者体内可能存在基因型不同的细胞混合体（嵌合体）。scCNV 可以精确地识别和量化这些嵌合体，帮助医生进行更准确的诊断和遗传咨询。这对于那些具有低水平嵌合突变的疾病尤其重要，因为批量测序可能无法检测到它们。</li>
</ul>
<h3 id="5-药物研发与毒理学">5. 药物研发与毒理学</h3>
<ul>
<li><strong>药物靶点发现：</strong> 通过识别疾病细胞中特异性扩增的基因，可以发现新的药物靶点。</li>
<li><strong>药物敏感性/耐药性标记：</strong> CNV 可以作为预测患者对某种药物响应的生物标志物。</li>
<li><strong>细胞系质量控制：</strong> 在药物筛选和研究中使用的细胞系可能会积累 CNV，scCNV 可以帮助对细胞系进行质量控制，确保其遗传稳定性。</li>
</ul>
<p>通过这些广泛的应用，scCNV 正在将我们对生物学和疾病的理解从宏观层面推向微观的、单细胞的精度，为精准医学和个性化治疗开辟了新的道路。</p>
<h2 id="前沿技术与未来展望">前沿技术与未来展望</h2>
<p>单细胞基因组学领域日新月异，scCNV 检测也不例外。随着新技术的不断涌现和计算方法学的持续创新，scCNV 的分辨率、准确性和应用范围将得到进一步提升。</p>
<h3 id="1-长读长单细胞测序-Long-read-scDNA-seq">1. 长读长单细胞测序 (Long-read scDNA-seq)</h3>
<p>当前大多数 scDNA-seq 都是基于短读长测序平台（如 Illumina），它们在检测大的 CNV 时表现良好，但在解析复杂结构变异（如倒位、平衡易位以及一些小型但复杂的 CNV）方面存在局限。长读长测序（如 Pacific Biosciences (PacBio) HiFi 和 Oxford Nanopore Technologies (ONT)）能够跨越重复区域和复杂基因组结构，提供更全面的结构变异信息。</p>
<ul>
<li><strong>潜力：</strong>
<ul>
<li><strong>高分辨率复杂 CNV 检测：</strong> 能够识别短读长无法解析的复杂重排和嵌套 CNV。</li>
<li><strong>更好地解析重复区域：</strong> 许多 CNV 发生在高度重复区域，长读长可以跨越这些重复区域，提供更精确的定位。</li>
<li><strong>同时检测点突变和结构变异：</strong> 有望在单次实验中同时捕获 SNP、Indel 和 CNV，提供更全面的基因组图谱。</li>
</ul>
</li>
<li><strong>挑战：</strong> 长读长单细胞测序目前仍面临高成本、低通量和高错误率（尽管 PacBio HiFi 已显著降低）的挑战。如何将 WGA 的偏倚与长读长数据相结合进行 CNV 估计，也需要新的计算方法。</li>
</ul>
<h3 id="2-空间基因组学与-scCNV">2. 空间基因组学与 scCNV</h3>
<p>传统的单细胞测序技术需要将细胞从组织中解离出来，从而丧失了细胞在组织中的原始空间位置信息。空间基因组学技术能够保留细胞的空间上下文信息，这对于理解 CNV 在肿瘤微环境中的分布和演化至关重要。</p>
<ul>
<li><strong>潜力：</strong>
<ul>
<li><strong>CNV 的空间异质性：</strong> 能够揭示肿瘤内不同区域的克隆 CNV 差异，例如核心区域与浸润前沿的 CNV 模式可能不同。</li>
<li><strong>肿瘤微环境中的克隆演化：</strong> 了解 CNV 携带的肿瘤细胞如何与周围的基质细胞和免疫细胞相互作用，以及这种相互作用如何影响肿瘤的演化和转移。</li>
<li><strong>发现新的预后/治疗标志物：</strong> 基于空间位置的 CNV 模式可能成为更准确的预后或治疗响应预测指标。</li>
</ul>
</li>
<li><strong>技术进展：</strong> Visium、MERFISH、Slide-seq 等空间转录组学技术已经成熟。结合这些技术，可以推断空间 CNV。未来，直接在组织切片上进行空间 scDNA-seq 将是重要的发展方向。</li>
</ul>
<h3 id="3-机器学习与深度学习在-scCNV-中的应用">3. 机器学习与深度学习在 scCNV 中的应用</h3>
<p>随着机器学习和深度学习技术的成熟，它们在处理高维、高噪音的生物数据方面展现出强大能力。</p>
<ul>
<li><strong>噪音去除与特征提取：</strong> 深度学习模型可以学习数据中的复杂模式，有效识别并去除 WGA 引入的噪音和批次效应，从而提取出更纯净的 CNV 信号。</li>
<li><strong>更准确的分段和聚类：</strong> 神经网络可以学习 CNV 信号的非线性特征，实现更精确的基因组分段。无监督学习（如自动编码器、变分自动编码器 (VAE)）可以用于对单细胞 CNV 模式进行聚类，从而识别出潜在的细胞亚群或克隆。</li>
<li><strong>假阳性/假阴性预测：</strong> 训练分类模型来区分真实的生物学 CNV 和技术伪影，提高检测的准确率。</li>
<li><strong>迁移学习与多任务学习：</strong> 利用大量已有的批量 CNV 数据集训练模型，然后将其知识迁移到数据量较小的单细胞 CNV 分析中。或者通过多任务学习，同时进行 CNV 检测和细胞类型识别。</li>
<li><strong>生成模型：</strong> 例如，生成对抗网络 (GAN) 可以用于生成模拟的单细胞 CNV 数据，帮助算法的开发和测试。</li>
</ul>
<h3 id="4-多组学整合分析的趋势">4. 多组学整合分析的趋势</h3>
<p>单个组学数据往往只能提供细胞某个层面的信息。将 scDNA-seq、scRNA-seq、scATAC-seq 甚至单细胞蛋白质组学数据整合起来进行分析，可以提供更全面、更深入的细胞状态理解。</p>
<ul>
<li><strong>相互印证 CNV：</strong> 通过 scDNA-seq 检测到的 CNV，可以通过 scRNA-seq 中对应基因表达量的变化或 scATAC-seq 中染色质可及性的变化来验证，增加 CNV 发现的置信度。</li>
<li><strong>功能解读：</strong> CNV 的功能影响可以通过多组学数据进行深入解析。例如，一个基因的扩增不仅可以通过 scDNA-seq 检测到，其导致的基因表达上调和染色质开放程度的改变也可以通过 scRNA-seq 和 scATAC-seq 观察到，从而更全面地理解该 CNV 的生物学后果。</li>
<li><strong>识别驱动克隆：</strong> 结合 CNV、基因表达和细胞表面标记等信息，可以更准确地识别具有特定功能（如耐药性、转移能力）的驱动克隆。</li>
</ul>
<h3 id="5-临床转化潜力">5. 临床转化潜力</h3>
<p>最终，scCNV 技术的进步将推动其在临床诊断和治疗中的应用。</p>
<ul>
<li><strong>癌症的早期诊断与预后：</strong> 识别早期肿瘤细胞中的特异性 CNV，有助于早期发现癌症。CNV 谱系可能作为预测患者预后和治疗响应的生物标志物。</li>
<li><strong>精准治疗指导：</strong> 基于单细胞 CNV 精确刻画的肿瘤异质性，可以指导医生选择最适合患者的靶向治疗或免疫疗法，甚至设计联合疗法来克服耐药性。</li>
<li><strong>实时监测疾病进展：</strong> 通过液体活检技术（如循环肿瘤细胞或 ctDNA）结合 scCNV 分析，实现对肿瘤动态演化和治疗响应的实时、非侵入性监测，为临床决策提供依据。</li>
<li><strong>遗传病的诊断与咨询：</strong> 对单细胞层面的嵌合体 CNV 或罕见 CNV 的识别，将极大地提升遗传病诊断的精确度。</li>
</ul>
<p>总而言之，单细胞拷贝数变异的分析正在从一个新兴领域迅速发展成为生物医学研究的强大工具。未来的发展将聚焦于更高分辨率、更低成本、更高通量的技术创新，更智能、更鲁棒的计算方法，以及多组学和空间信息的深度整合。我们有理由相信，scCNV 将在揭示生命奥秘、攻克复杂疾病的道路上发挥越来越关键的作用。</p>
<h2 id="结论">结论</h2>
<p>在本次深入探索之旅中，我们一同穿越了基因组的广阔天地，聚焦于单细胞拷贝数变异这一微观而又宏大的生物学现象。从 CNV 的基本概念和生物学意义，到单细胞测序技术的独特挑战与机遇，再到基于测序深度、等位基因和多模态推断的各类精妙计算方法，我们解析了其背后的数学原理和统计考量。我们还直面了 scCNV 分析在实践中遇到的噪音、稀疏性、计算负担等诸多挑战，并展望了这项技术在肿瘤学、发育生物学、神经科学乃至临床转化中的广阔应用前景。</p>
<p>单细胞基因组中的拷贝数变异，是细胞命运变迁、疾病发生发展乃至生命适应演化的重要表征。它们是基因组的“指纹”，记录着细胞经历的每一步“战役”：从正常的发育分化，到肿瘤细胞的增殖、侵袭与耐药，每一个关键节点都可能伴随着特异性的 CNV。传统的批量测序，如同通过浑浊的滤镜观察一个喧嚣的战场，只能看到模糊的整体。而单细胞基因组学，则赋予了我们透视微观战场的超能力，让我们能够看清每一个“士兵”（细胞）的装备（CNV），以及它们在战场上（组织微环境）的位置和策略。</p>
<p>然而，这场微观战役的解析并非易事。单细胞数据固有的低输入、扩增偏倚和高噪音，要求我们必须依赖先进的生物信息学算法和强大的计算能力。隐马尔可夫模型、改变点检测、统计归一化——这些看似抽象的数学工具，正是我们从混乱的测序数据中抽丝剥茧、识别真实信号的利器。</p>
<p>展望未来，我们有理由保持乐观和兴奋。随着长读长测序、空间基因组学等前沿技术的不断成熟，以及机器学习、深度学习在处理复杂生物数据方面的日益精进，单细胞 CNV 的检测精度和分辨率将达到前所未有的高度。多组学数据的整合，将为我们提供更全面的细胞功能图谱，使我们不仅能知道“哪里”发生了 CNV，更能理解“为什么”以及“如何”影响细胞功能。</p>
<p>从实验室的发现到临床的转化，scCNV 分析正逐步成为精准医学的基石。它有望在癌症的早期诊断、耐药性机制的揭示、个性化治疗方案的制定，乃至遗传疾病的精准诊断和产前筛查中发挥关键作用。</p>
<p>这是一场激动人心的旅程，我们才刚刚开始。作为技术爱好者，我们有幸亲历这场由数据科学驱动的生物学革命。愿我们继续保持好奇，不断探索，共同揭示生命更深层次的奥秘。</p>
<p>感谢大家的阅读，我们下次再见！</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/qmwneb946">qmwneb946</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qmwneb946.dpdns.org/2025/07/24/2025-07-25-000355/">https://qmwneb946.dpdns.org/2025/07/24/2025-07-25-000355/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a> 许可协议。转载请注明来源 <a href="https://qmwneb946.dpdns.org" target="_blank">qmwneb946 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%A6/">数学</a><a class="post-meta__tags" href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%95%B0%E5%8F%98%E5%BC%82/">单细胞基因组的拷贝数变异</a></div><div class="post-share"><div class="social-share" data-image="/img/icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/24/2025-07-25-022636/" title="蛋白质翻译的精确调控：生命活动中的复杂算法与控制系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">蛋白质翻译的精确调控：生命活动中的复杂算法与控制系统</div></div><div class="info-2"><div class="info-item-1"> 生命，无疑是地球上最精妙的复杂系统。从单细胞的细菌到万物之灵的人类，所有生物的活动都依赖于一类被称为蛋白质的分子机器。蛋白质的种类和功能极其丰富，它们构成了细胞的结构骨架，催化着生化反应，传递着信号，并执行着无数至关重要的生命任务。而这一切的起点，是DNA所承载的遗传信息，通过转录生成信使RNA (mRNA)，最终在核糖体上被“翻译”成蛋白质。这个过程，远非简单的信息传递链条，而是一个受到极致精确调控、高度动态响应的复杂控制系统——就如同一个高性能计算集群，其每一个任务的执行，每一个资源的分配，都经过深思熟虑的调度与优化。 作为一位技术和数学爱好者，我们不禁会好奇：细胞是如何在毫秒间精准地决定生产哪种蛋白质、生产多少以及何时停止？这种精密性背后隐藏着怎样的“算法”和“工程学”原理？在本文中，我们将深入探讨蛋白质翻译的精确调控机制，从宏观的阶段划分到微观的分子相互作用，从能量消耗的经济学视角到疾病发生中的失衡现象，试图揭示生命系统如何像一位经验丰富的工程师那样，构建并优化着这台核心的蛋白质合成引擎。 蛋白质翻译的基石：一个宏观概述 在深入探讨翻译调控之前，我们首先要理解蛋白质翻译...</div></div></div></a><a class="pagination-related" href="/2025/07/24/2025-07-25-000218/" title="细胞的终章：深入剖析凋亡与坏死的奥秘与差异"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">细胞的终章：深入剖析凋亡与坏死的奥秘与差异</div></div><div class="info-2"><div class="info-item-1">致读者： 作为一名常年游走于技术与数学疆界的博主，我深知每一个复杂系统背后都隐藏着优雅的逻辑与精密的机制。从芯片上的晶体管开关到宇宙中的星系演化，无不如此。而当我们把目光投向生命最基本的单元——细胞时，这种精妙更是展现得淋漓尽致。细胞的生老病死，不仅仅是生命现象的表象，更是一系列严谨的、有时是程序化的、有时是意外的“算法”和“协议”在幕后运行的结果。 今天，我们将深入探讨细胞生命周期的最终阶段：细胞死亡。你可能会觉得死亡是终结，但对于生命系统而言，细胞死亡往往是维持稳态、清除有害物质、乃至塑造形态的关键环节。我们将重点剖析两种最主要、也最常被提及的细胞死亡模式：细胞凋亡 (Apoptosis) 和 细胞坏死 (Necrosis)。这不仅仅是生物学上的概念区分，更像是操作系统中“优雅关机”与“意外崩溃”的对比，理解它们，能帮助我们更好地把握生命的逻辑，洞察疾病的本质。 准备好了吗？让我们一同踏上这段探索细胞终章的旅程。  引言：细胞命运的抉择 生命，是一场连续而动态的平衡。在每一个生命体内部，数十亿、万亿的细胞以令人惊叹的协同方式工作着，构建组织，形成器官，维持功能。然而，正如世间...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/18/2025-07-18-082519/" title="增强现实与工业维修：一场效率革命"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">增强现实与工业维修：一场效率革命</div></div><div class="info-2"><div class="info-item-1">增强现实 (AR) 技术正以前所未有的速度改变着我们的生活，而其在工业维修领域的应用更是展现出了巨大的潜力。不再局限于科幻电影中的场景，AR 如今已成为提升维修效率、降低维护成本、提高安全性的强大工具。本文将深入探讨 AR 如何与工业维修相结合，并分析其背后的技术和未来发展趋势。 引言：传统工业维修的挑战 传统的工业维修往往面临着诸多挑战：  信息获取困难: 维修人员需要查阅大量的纸质文档、图纸和视频，耗时费力，容易出错。 培训成本高昂:  熟练技工的培养需要漫长的学习过程和大量的实践经验，成本高昂。 安全风险较高:  一些复杂的设备维修存在高风险，例如高压电、高温部件等，容易发生意外事故。 维修效率低下:  由于缺乏实时信息和有效的指导，维修时间往往较长，导致生产停机时间增加，损失巨大。  AR 如何改变工业维修的游戏规则 AR 技术通过将数字信息叠加到现实世界中，为工业维修提供了全新的解决方案： 远程专家指导 通过 AR 眼镜或平板电脑，现场维修人员可以与远程专家实时互动。专家可以通过 AR 系统看到现场设备的实时图像，并利用虚拟标注、3D 模型等工具进行远程指导，大大缩短了...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082652/" title="纳米材料在靶向药物中的革命性应用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">纳米材料在靶向药物中的革命性应用</div></div><div class="info-2"><div class="info-item-1">近年来，癌症等重大疾病的治疗面临着巨大的挑战，传统的化疗药物往往毒性大、副作用强，难以实现精准治疗。而纳米技术的兴起为解决这一难题提供了新的思路，特别是纳米材料在靶向药物递送系统中的应用，正引发一场医学革命。本文将深入探讨纳米材料如何提升靶向药物的疗效，降低其毒副作用。 纳米材料的特性及其在药物递送中的优势 纳米材料，是指至少在一个维度上尺寸小于100纳米的材料。这种极小的尺寸赋予了它们许多独特的物理和化学性质，使其在药物递送领域具有显著优势： 增强的药物溶解度和稳定性 许多药物具有较低的溶解度，限制了其在体内的吸收和生物利用度。纳米载体，例如脂质体、聚合物纳米颗粒和无机纳米颗粒（如金纳米颗粒、氧化铁纳米颗粒），可以显著提高药物的溶解度和稳定性，延长其在体内的循环时间。例如，将抗癌药物负载在聚合物纳米颗粒中，可以保护药物免受降解，并提高其在肿瘤组织中的积累。 靶向药物递送 纳米材料可以通过表面修饰，例如结合特异性配体（如抗体、肽或小分子），实现对特定细胞或组织的靶向递送。这种靶向递送可以最大限度地减少药物对健康组织的毒性，并提高药物在靶标部位的浓度，从而增强治疗效果。例如，修饰有...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-082925/" title="生物化学中的蛋白质折叠问题：一个复杂而迷人的计算挑战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">生物化学中的蛋白质折叠问题：一个复杂而迷人的计算挑战</div></div><div class="info-2"><div class="info-item-1">生命，这奇妙的现象，其本质很大程度上取决于蛋白质的精确三维结构。蛋白质是由氨基酸链组成的长链分子，但仅仅是氨基酸序列并不能完全决定其功能。蛋白质必须折叠成特定的三维结构（构象），才能发挥其生物学功能，例如催化酶促反应、运输分子或构建细胞结构。  而这个折叠过程，就是著名的“蛋白质折叠问题”。 蛋白质折叠：从线性序列到三维结构 蛋白质的氨基酸序列由基因编码决定，这是一个线性的一维结构。然而，这些氨基酸链并非随机地盘踞在一起，而是会遵循特定的物理和化学原理，自发地折叠成独特的、功能性的三维结构。这个折叠过程涉及到多种相互作用，包括： 疏水相互作用 蛋白质内部的疏水氨基酸残基倾向于聚集在一起，远离水性环境，形成蛋白质的核心区域。而亲水性氨基酸残基则倾向于暴露在蛋白质的表面，与水分子相互作用。 静电相互作用 带电荷的氨基酸残基之间会发生静电吸引或排斥作用，影响蛋白质的折叠。 氢键 氢键在维持蛋白质二级结构（例如α螺旋和β折叠）中起着关键作用。 二硫键 某些氨基酸残基（例如半胱氨酸）之间可以形成二硫键，进一步稳定蛋白质的三维结构。 这些相互作用共同决定了蛋白质的最终构象，这是一个极其复杂的...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-092536/" title="CRISPR基因编辑：技术的奇迹与伦理的挑战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">CRISPR基因编辑：技术的奇迹与伦理的挑战</div></div><div class="info-2"><div class="info-item-1">大家好！我是你们的技术和数学博主，今天我们要深入探讨一个既令人兴奋又充满争议的话题：CRISPR-Cas9基因编辑技术及其伦理挑战。CRISPR技术以其精准性和效率，为治疗遗传疾病、改良作物等领域带来了革命性的变革，但与此同时，它也引发了诸多伦理难题，需要我们认真思考和谨慎应对。 CRISPR技术：一把双刃剑 CRISPR-Cas9系统，简单来说，就是一种可以精确地“剪切和粘贴”DNA的工具。它源自细菌的天然防御机制，利用向导RNA（gRNA）引导Cas9酶到基因组中的特定位置，从而进行基因的敲除、插入或替换。其操作简便、成本低廉、效率高，使其成为基因编辑领域的“明星”技术。 CRISPR的工作原理 CRISPR系统的工作机制可以概括为以下几个步骤：  设计gRNA:  根据目标基因序列设计相应的gRNA，使其能够特异性地结合目标DNA序列。 Cas9酶的结合: gRNA引导Cas9酶到目标DNA序列。 DNA双链断裂: Cas9酶在目标位点切割DNA双链，形成双链断裂（DSB）。 DNA修复: 细胞利用非同源末端连接（NHEJ）或同源定向修复（HDR）机制修复DSB。NHEJ修...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-094115/" title="免疫学与癌症免疫疗法：一场人体内部的战争与和平"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">免疫学与癌症免疫疗法：一场人体内部的战争与和平</div></div><div class="info-2"><div class="info-item-1">免疫系统，人体精妙的防御机制，日夜不停地抵御着病毒、细菌和其他有害物质的入侵。然而，当这套系统出现故障，对自身细胞发起攻击，或者无法有效清除癌细胞时，疾病便会发生，其中最可怕的莫过于癌症。近年来，癌症免疫疗法异军突起，为癌症治疗带来了新的希望，让我们深入探索这场人体内部的战争与和平。 免疫系统：人体精妙的防御网络 我们的免疫系统由先天免疫和适应性免疫两大支柱组成。 先天免疫：第一道防线 先天免疫是人体抵御病原体的第一道防线，它包含物理屏障（例如皮肤和黏膜）、化学屏障（例如胃酸和酶）以及细胞介导的免疫反应，例如巨噬细胞和自然杀伤细胞（NK细胞）的吞噬和杀伤作用。这些细胞能够识别并清除被感染的细胞或癌细胞，但其特异性较低。 适应性免疫：精准打击 适应性免疫系统则更为精细，它具有特异性和记忆性。T细胞和B细胞是适应性免疫的主角。T细胞负责细胞介导的免疫，其中细胞毒性T细胞（CTL）能够特异性识别并杀死靶细胞，例如被病毒感染的细胞或癌细胞。B细胞则负责体液免疫，产生抗体，中和病原体或标记癌细胞以便清除。  抗原呈递细胞（APC），例如树突状细胞，在将抗原信息呈递给T细胞，启动适应性免疫反...</div></div></div></a><a class="pagination-related" href="/2025/07/18/2025-07-18-094141/" title="生态学中的生物多样性保护：一个复杂系统工程的视角"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-18</div><div class="info-item-2">生态学中的生物多样性保护：一个复杂系统工程的视角</div></div><div class="info-2"><div class="info-item-1">大家好！今天我们要深入探讨一个既充满挑战又至关重要的话题：生态学中的生物多样性保护。  这不仅是环境保护的基石，也与我们人类的福祉息息相关。对技术爱好者来说，这更像是一个巨大的、复杂的系统工程，充满了需要解决的优化问题和值得探索的算法。 生物多样性的价值：超越简单的物种数量 我们通常将生物多样性理解为物种数量的多样性。但实际上，它是一个多层次的概念，包括：  遗传多样性 (Genetic Diversity):  同一物种内基因组的差异性，这决定了物种的适应性和进化潜力。  想象一下，一个抗旱基因的缺失可能导致整个小麦品种在干旱年份面临灭绝的风险。 物种多样性 (Species Diversity):  不同物种的数量及其相对丰度。 这通常用Shannon多样性指数 (H=−∑i=1Spilog⁡2piH = -\sum_{i=1}^{S} p_i \log_2 p_iH=−∑i=1S​pi​log2​pi​) 来衡量，其中 pip_ipi​ 是第 iii 个物种的比例，SSS 是物种总数。  更高的Shannon指数表示更高的物种多样性。 生态系统多样性 (Ecosystem ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">qmwneb946</div><div class="author-info-description">一个专注于技术分享的个人博客，涵盖编程、算法、系统设计等内容</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1347</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1351</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qmwneb946"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/qmwneb946" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:qmwneb946@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">代码与远方，技术与生活交织的篇章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E8%88%9E%E8%80%85%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%95%B0%E5%8F%98%E5%BC%82-CNV-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基因组的动态舞者：拷贝数变异 (CNV) 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%B7%E8%B4%9D%E6%95%B0%E5%8F%98%E5%BC%82%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是拷贝数变异？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CNV-%E7%9A%84%E7%94%9F%E7%89%A9%E5%AD%A6%E6%84%8F%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">CNV 的生物学意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AD%A3%E5%B8%B8%E7%94%9F%E7%90%86%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%B8%AA%E4%BD%93%E5%A4%9A%E6%A0%B7%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 正常生理功能与个体多样性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%8D%E6%9D%82%E7%96%BE%E7%97%85%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 复杂疾病的驱动因素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-CNV-%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">传统 CNV 检测方法的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%B9%E9%87%8F%E6%B5%8B%E5%BA%8F%E7%9A%84%E2%80%9C%E5%B9%B3%E5%9D%87%E6%95%88%E5%BA%94%E2%80%9D"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 批量测序的“平均效应”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%86%E8%83%9E%E9%81%97%E4%BC%A0%E5%AD%A6%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 细胞遗传学方法的低分辨率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BE%E5%A4%A7%E9%95%9C%E4%B8%8B%E7%9A%84%E5%8D%95%E7%BB%86%E8%83%9E%E4%B8%96%E7%95%8C%EF%BC%9A%E5%8D%95%E7%BB%86%E8%83%9E%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6%E6%A6%82%E8%A7%88"><span class="toc-number">2.</span> <span class="toc-text">放大镜下的单细胞世界：单细胞基因组学概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8D%95%E7%BB%86%E8%83%9E%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">为什么需要单细胞基因组学？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BB%86%E8%83%9E%E6%B5%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.</span> <span class="toc-text">单细胞测序技术简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E7%BB%86%E8%83%9E-DNA-%E6%B5%8B%E5%BA%8F-scDNA-seq"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 单细胞 DNA 测序 (scDNA-seq)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E7%BB%86%E8%83%9E-RNA-%E6%B5%8B%E5%BA%8F-scRNA-seq"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 单细胞 RNA 测序 (scRNA-seq)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%95%E7%BB%86%E8%83%9E-ATAC-%E6%B5%8B%E5%BA%8F-scATAC-seq"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. 单细胞 ATAC 测序 (scATAC-seq)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BB%86%E8%83%9E-DNA-%E6%B5%8B%E5%BA%8F%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">2.3.</span> <span class="toc-text">单细胞 DNA 测序的挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%89%A9%E5%A2%9E-WGA-%E5%81%8F%E5%80%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 全基因组扩增 (WGA) 偏倚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%8E%E8%B5%B7%E5%A7%8B-DNA-%E9%87%8F%E4%B8%8E%E8%A6%86%E7%9B%96%E5%BA%A6%E4%B8%8D%E8%B6%B3"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 低起始 DNA 量与覆盖度不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%81%87%E9%98%B3%E6%80%A7%E5%92%8C%E5%81%87%E9%98%B4%E6%80%A7-CNV"><span class="toc-number">2.3.3.</span> <span class="toc-text">3. 假阳性和假阴性 CNV</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BB%86%E8%83%9E%E6%8B%B7%E8%B4%9D%E6%95%B0%E5%8F%98%E5%BC%82-scCNV-%E6%A3%80%E6%B5%8B%EF%BC%9A%E7%90%86%E8%AE%BA%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">单细胞拷贝数变异 (scCNV) 检测：理论与方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scCNV-%E6%A3%80%E6%B5%8B%E7%9A%84%E7%8B%AC%E7%89%B9%E6%8C%91%E6%88%98"><span class="toc-number">3.1.</span> <span class="toc-text">scCNV 检测的独特挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E7%9A%84-scCNV-%E6%A3%80%E6%B5%8B-Read-Depth-Based"><span class="toc-number">3.2.</span> <span class="toc-text">基于深度的 scCNV 检测 (Read Depth Based)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-number">3.2.2.</span> <span class="toc-text">标准化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">分段算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E8%A1%A8%E6%80%A7%E5%B7%A5%E5%85%B7"><span class="toc-number">3.2.4.</span> <span class="toc-text">代表性工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AD%89%E4%BD%8D%E5%9F%BA%E5%9B%A0%E7%9A%84-scCNV-%E6%A3%80%E6%B5%8B-Allele-Specific-Based"><span class="toc-number">3.3.</span> <span class="toc-text">基于等位基因的 scCNV 检测 (Allele-Specific Based)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%91%E6%88%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">3.3.3.</span> <span class="toc-text">工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%A8%A1%E6%80%81%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90-Integrating-scRNA-seq-scATAC-seq-for-scCNV-Inference"><span class="toc-number">3.4.</span> <span class="toc-text">多模态数据集成 (Integrating scRNA-seq&#x2F;scATAC-seq for scCNV Inference)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">3.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E5%B1%80%E9%99%90"><span class="toc-number">3.4.2.</span> <span class="toc-text">优点与局限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E8%A1%A8%E6%80%A7%E5%B7%A5%E5%85%B7-2"><span class="toc-number">3.4.3.</span> <span class="toc-text">代表性工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E6%A0%B8%E5%BF%83%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">计算方法核心数学原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B5%8B%E5%BA%8F%E6%B7%B1%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1"><span class="toc-number">3.5.1.</span> <span class="toc-text">1. 测序深度数据的统计建模</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B-HMM-%E5%9C%A8%E5%88%86%E6%AE%B5%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.5.2.</span> <span class="toc-text">2. 隐马尔可夫模型 (HMM) 在分段中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%94%B9%E5%8F%98%E7%82%B9%E6%A3%80%E6%B5%8B-Changepoint-Detection"><span class="toc-number">3.5.3.</span> <span class="toc-text">3. 改变点检测 (Changepoint Detection)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E6%8C%91%E6%88%98%E4%B8%8E%E8%80%83%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">实践中的挑战与考量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8A%80%E6%9C%AF%E5%99%AA%E9%9F%B3%E4%B8%8E%E6%89%B9%E6%AC%A1%E6%95%88%E5%BA%94"><span class="toc-number">4.1.</span> <span class="toc-text">1. 技术噪音与批次效应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%A8%80%E7%96%8F%E6%80%A7%E4%B8%8E%E8%A6%86%E7%9B%96%E5%BA%A6"><span class="toc-number">4.2.</span> <span class="toc-text">2. 数据稀疏性与覆盖度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E4%B8%8E%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">3. 计算资源与可伸缩性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%82%E8%80%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%8E%E6%B3%A8%E9%87%8A%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">4. 参考基因组与注释的准确性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%94%9F%E7%89%A9%E5%AD%A6%E5%81%87%E9%98%B3%E6%80%A7%E4%B8%8E%E5%81%87%E9%98%B4%E6%80%A7"><span class="toc-number">4.5.</span> <span class="toc-text">5. 生物学假阳性与假阴性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%82%BF%E7%98%A4%E5%BC%82%E8%B4%A8%E6%80%A7%E4%B8%8E%E5%85%8B%E9%9A%86%E6%BC%94%E5%8C%96"><span class="toc-number">4.6.</span> <span class="toc-text">6. 肿瘤异质性与克隆演化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scCNV-%E5%9C%A8%E7%94%9F%E7%89%A9%E5%8C%BB%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">scCNV 在生物医学研究中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%82%BF%E7%98%A4%E6%BC%94%E5%8C%96%E4%B8%8E%E8%80%90%E8%8D%AF%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">1. 肿瘤演化与耐药性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%91%E8%82%B2%E7%94%9F%E7%89%A9%E5%AD%A6%E4%B8%8E%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6"><span class="toc-number">5.2.</span> <span class="toc-text">2. 发育生物学与神经科学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E8%BA%AB%E5%85%8D%E7%96%AB%E6%80%A7%E7%96%BE%E7%97%85%E4%B8%8E%E6%84%9F%E6%9F%93"><span class="toc-number">5.3.</span> <span class="toc-text">3. 自身免疫性疾病与感染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%A7%E5%89%8D%E8%AF%8A%E6%96%AD%E4%B8%8E%E9%81%97%E4%BC%A0%E5%92%A8%E8%AF%A2"><span class="toc-number">5.4.</span> <span class="toc-text">4. 产前诊断与遗传咨询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%8D%AF%E7%89%A9%E7%A0%94%E5%8F%91%E4%B8%8E%E6%AF%92%E7%90%86%E5%AD%A6"><span class="toc-number">5.5.</span> <span class="toc-text">5. 药物研发与毒理学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-number">6.</span> <span class="toc-text">前沿技术与未来展望</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%95%BF%E8%AF%BB%E9%95%BF%E5%8D%95%E7%BB%86%E8%83%9E%E6%B5%8B%E5%BA%8F-Long-read-scDNA-seq"><span class="toc-number">6.1.</span> <span class="toc-text">1. 长读长单细胞测序 (Long-read scDNA-seq)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A9%BA%E9%97%B4%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6%E4%B8%8E-scCNV"><span class="toc-number">6.2.</span> <span class="toc-text">2. 空间基因组学与 scCNV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9C%A8-scCNV-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">3. 机器学习与深度学习在 scCNV 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E7%BB%84%E5%AD%A6%E6%95%B4%E5%90%88%E5%88%86%E6%9E%90%E7%9A%84%E8%B6%8B%E5%8A%BF"><span class="toc-number">6.4.</span> <span class="toc-text">4. 多组学整合分析的趋势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%B4%E5%BA%8A%E8%BD%AC%E5%8C%96%E6%BD%9C%E5%8A%9B"><span class="toc-number">6.5.</span> <span class="toc-text">5. 临床转化潜力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">7.</span> <span class="toc-text">结论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/hello-world/" title="Hello World">Hello World</a><time datetime="2025-07-26T07:43:24.714Z" title="发表于 2025-07-26 15:43:24">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="博弈论基础">博弈论基础</a><time datetime="2025-07-26T07:43:24.714Z" title="发表于 2025-07-26 15:43:24">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/2025-07-26-074018/" title="微生物的代谢多样性：生命基石的无限变奏">微生物的代谢多样性：生命基石的无限变奏</a><time datetime="2025-07-25T23:40:18.000Z" title="发表于 2025-07-26 07:40:18">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/2025-07-26-073926/" title="免疫系统的记忆与遗忘：生命演化中的信息管理与权衡">免疫系统的记忆与遗忘：生命演化中的信息管理与权衡</a><time datetime="2025-07-25T23:39:26.000Z" title="发表于 2025-07-26 07:39:26">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/2025-07-26-073836/" title="决策的神经经济学：从理性模型到大脑深层机制的探索">决策的神经经济学：从理性模型到大脑深层机制的探索</a><time datetime="2025-07-25T23:38:36.000Z" title="发表于 2025-07-26 07:38:36">2025-07-26</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By qmwneb946</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'qmwneb946/blog',
      'data-repo-id': 'R_kgDOPM6cWw',
      'data-category-id': 'DIC_kwDOPM6cW84CtEzo',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>